<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=gb2312">
  <title>乡下小老鼠日常笔记</title>
  <link href="TryDoxygen.css" rel="stylesheet" type="text/css">
  <meta name="robots" content="index,nofollow">
</head>
<table width="100%" bgColor="#99CCFF">
<tr align=left>
	<td align=left height=46 class="style1"><a href="index.html">
<img class="logo" src="logo.png" height="46" alt="" 
            style="background-color: #99CCFF; background-image: none;" /></a></td> <td align=center>
        <font size=6 color="#FFFFFF" face=""><b>乡下小老鼠日常笔记</b></font>
	</td><td align=left height=46 class="style1">
<img class="space" src="space.png" height="46" alt="" 
            style="background-color: #99CCFF; background-image: none;" /></td>
</tr> </table>
<!-- 制作者 Doxygen 1.8.15 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Emacs迷你手册（第一部分）-基础知识 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>作者</dt><dd>from <a href="http://tuhdo.github.io/emacs-tutor.html">http://tuhdo.github.io/emacs-tutor.html</a> <hr/>
 </dd></dl>
<h1><a class="anchor" id="whyemacs"></a>
为什么要用Emacs？</h1>
<p>除了编辑文本外，使用Emacs还可以做很多事情，Emacs是一个编程平台，不是通常意义上的编辑器，更多细节可以参考附录和阅读官方主页上的教程。</p>
<p>本文是我的教程，添加了第三方插件的讲述。如果你的Emacs和我的截图看着不一样，不要担心。你可以配置的和我一样，甚至更好，但现在你要先打好基础。这里的截图只是为了演示。即使这样，读完本教材后，你将可以使用Emacs方便的阅读Linux内核源码树。</p>
<ul>
<li>性能：编辑39M大小的c源码不成问题，但是，如果编辑一个如此大的文件而崩溃，不是你最喜欢的编辑器的过错。 <center> <div class="image">
<img src="performance.gif" alt="performance.gif"/>
</div>
 </center></li>
<li>编程：<ol type="1">
<li>跳转到任意头文件 <center> <div class="image">
<img src="jump_headers.gif" alt="jump_headers.gif"/>
</div>
 </center></li>
<li>自动补全：注意添加inclde &lt;linux/printk.h&gt;添加前后补全候选的变化 <center> <div class="image">
<img src="auto_complete.gif" alt="auto_complete.gif"/>
</div>
 </center></li>
<li>显示函数参数： <center> <div class="image">
<img src="func_args.jpg" alt="func_args.jpg"/>
</div>
 </center></li>
<li>多行快速注释： <center> <div class="image">
<img src="comment.gif" alt="comment.gif"/>
</div>
 </center></li>
<li>GDB： <center> <div class="image">
<img src="gdb-many-windows.gif" alt="gdb-many-windows.gif"/>
</div>
 </center></li>
</ol>
</li>
<li>当前编辑文件与文件最后版本的区别 <center> <div class="image">
<img src="vc-diff.jpg" alt="vc-diff.jpg"/>
</div>
 </center></li>
<li>魔法：从unstage到stage到commit到push <center> <div class="image">
<img src="magit.gif" alt="magit.gif"/>
</div>
 </center></li>
<li>动态grip <center> <div class="image">
<img src="live_grep.gif" alt="live_grep.gif"/>
</div>
 </center></li>
<li>快速从版本控制下的文件夹中快速选择任意文件，入从linux内核。示例中你可以看到我输入命令。你可以把他看做Windows的开始菜单，这些命令可以通过一个快捷键快速执行。 <center> <div class="image">
<img src="helm-projectile-find-files-1.gif" alt="helm-projectile-find-files-1.gif"/>
</div>
 </center></li>
<li>从以前的工作session中快速选择任意文件或目录 <center> <div class="image">
<img src="helm-buffer-list.gif" alt="helm-buffer-list.gif"/>
</div>
 </center></li>
<li>Emacs是一个PDF阅览器：我可以高亮搜索PDF中的文本并且在侧边有一个目录。一切都通过键盘控制 <center> <div class="image">
<img src="emacs-read-pdf.gif" alt="emacs-read-pdf.gif"/>
</div>
 </center> 最后，Emacs为<a href="http://jtnimoy.net/workviewer.php?q=178">Tron Legacy</a>的一个重要特色。 </li>
</ul>
<h1><a class="anchor" id="whythisguide"></a>
为什么要写这篇文章？</h1>
<p>让我们看看Emacs的手册：</p>
<center> <div class="image">
<img src="emacs-manual-toc.gif" alt="emacs-manual-toc.gif"/>
</div>
 </center> <p>所有文件处理相关的指导都在Files入口处，包括如何打开、保存、复原和自动复原、文件比较等等从初级到高级。如果你是一个初学者在读Emacs手册，你不得不停的在手册中查找学习在其他编辑器中的基本常用任务。</p>
<p>如果你一页一页的读手册，在你可以使用Emacs做基本的操作之前，你将耗费很长时间。基本编辑命令部分放在了包含文件操作信息的“Emacs主要结构”之前。如果连如何打开文件都不会，如何学习基本的编辑命令？手册的问题在于他不是为初学者逐步学习Emacs的方式组织的。</p>
<p>我将帮助你在一个较短的时间里高效的使用Emacs，大约需要一周时间。这就是我为什么写这篇指南尤其是那些完全的初学者。Emacs手册非常好，但是在有一个坚实的基础并使用Emacs一段时间后再读会比较好。</p>
<p>本指南为学习官方的Emacs手册开了一个好头。GNU Emacs的教程很不错，除了缺少一些演示。</p>
<h1><a class="anchor" id="hisant"></a>
一点点历史</h1>
<p>引用自GNU Emacs官方主页：给对Emacs历史好奇的人：Emacs最初在1976年以一系列TECO宏的形式完成于MIT AI实验室的Incompatible Timesharing System (ITS)。名字来源于Editor MACroS的缩写。当前版本的Emacs（GNU Emacs）最初写于1984年。更多信息参考Richard Stallman在1981年的文章，该文描述了原始Emacs的设计和从中学到的知识。和他2002年在国际Lisp大会上《我的Lisp经历和GNU Emacs开发》演讲的记录。涉及了ITS原始的Emacs手册，还有Twenex原始的Emacs手册以及（RMS唯一绘制的卡通图画）自描述可扩展编辑器。</p>
<h1><a class="anchor" id="antpd"></a>
除了像Notepad一样简单的编辑器，我不需要其他复杂的编辑器</h1>
<p>好吧，这是你的选择。但我认为在没有任何辅助功能的编辑器里写代码百害而无一利。如果自动化的代价没有超出手工完成，程序员应该尽可能的使自己的工作自动化。做这些的一个简单方式是使用一个好的编辑器自动完成很多细小无味的工作。例如:一个让我讨厌的工作是使用cd命令进入一个像下面这样复杂的路径里：</p>
<pre class="fragment">/path/to/a/very/long/long/long/long/long/long/..../directory/
</pre> <p>使用Emacs，如果你的文件夹在版本控制系统下，你可以立即调到任何文件，哪怕是他在20层深的地方。</p>
<p>另一个例子是快速注释：在只支持单行注释的编程语言中可以快速的注释掉多行代码。在许多编辑器中你不得不一行一行的进行注释，Emacs中你只需高亮这些列然后使用快捷键进行注释。</p>
<p>许多人认为手工编写代码可以使他们比那些使用自动化IDE的人显得更加的酷。我也曾经这么认为，这是因为在Linux下工作需要懂得后台的处理过程（如：使用C/C++的Makefile编译软件，使用脚本自动化，编译安装软件等等）。在Linux世界里，与点击几个按钮即可完成的IDE相比，这些已经公认为用户友好。但是，我错了。使用这个工具（Emacs）使我知道正在发生什么，而不需要手工输入代码来完成。如果你已经知道一个for循环做什么，逐字的输入是非常单调的工作，也常常会打断你的思路。</p>
<p>手工输入代码不会使你变得更聪明，因为你在输入之前进行思考。输入仅仅是你的思维在编辑器上的展示。你需要尽可能快的完成输入，因为你越快的完成输入就可以越快的回到思考。只有思考而不是成千上万次手工输入同样的事情更有价值，我不得不说剪切、拷贝和粘贴是非常伟大的想法，伟大的自动化工具是由于它们的简洁。</p>
<p>如果你的工作要求你是用一个内部难懂的语言，并且你不喜欢它，使用一个编辑器尽快的完成工作应该给你带来愉悦。</p>
<p>打字过多会导致RSI（Repetitive Strain Injury重复使力伤害）手工输入过多的代码会对你的手指造成伤害。至少如果你使用手锯而不是圆锯这个过程中你会做许多身体操练。</p>
<p>总之：</p><ul>
<li>手工输入不会使你变得更加聪明。</li>
<li>手工输入不会使你变成更好的程序员。</li>
<li>手工输入或其它无味的工作（切换文件系统，记住你对文件的修改内容等等）在可以自动化的情况下就是一种时间浪费。尽可能的自动化你的工作。</li>
<li>好的编辑器帮助你自动化烦人的工作。</li>
<li>打字过多可能导致RSI </li>
</ul>
<p>与其浪费时间和精力在无味的工作上你可以将之节省下来用于有趣的工作。 </p>
<h1><a class="anchor" id="install"></a>
安装</h1>
<h2><a class="anchor" id="Linuxin"></a>
Linux下的安装</h2>
<p>如果你使用Ubuntu一切都很简单，你只需输入：sudo apt-get install Emacs。如果你使用其他的Linux版本，使用相应的发布包管理方式进行安装。然而发布包管理方式仅能安装最近的稳定版本；如果你想使用最新版本，参照下面的指导从源码进行安装。</p>
<h3><a class="anchor" id="要使用带用户界面的Emacs："></a>
要使用带用户界面的Emacs：</h3>
<ul>
<li>安装GTK 3：sudo apt-get install libgtk-3-dev libgtk-3-common libgtk-3-0</li>
<li>下载Emacs或者如果你更喜欢最新版本的Emacs，从源中获取：git clone <a href="http://repo.or.cz/r/emacs.git">http://repo.or.cz/r/emacs.git</a></li>
<li>如果你从主页下载，解压缩：tar xvf emacs-*.tar.gz</li>
<li>安装GTK：sudo apt-get install libgtk-3-dev libgtk-3-common libgtk-3-0要想使用True type字体你需要使用gtk3.</li>
<li>cd emacs-&lt;version&gt;*</li>
<li>./autogen.sh</li>
<li>添加prefix和路径到你想要安装到的地方。如果你工作在一个没有root权限的远程服务的情况下这非常有用。./configure &ndash;with-x-toolkit=gtk3 [&ndash;prefix=/path/to/dir你需要使用GTKx这样你可以使用true type获得更好的Emacs体验。</li>
<li>make</li>
<li>sudo make install </li>
</ul>
<p>如果./configure提示依赖缺失，你需要进行安装。推荐的依赖包括：libtiff,libgiff,libjpeg,libpng和libxml2用于在Emacs内部查看和浏览网页。sudo apt-get install libtiff5-dev libpng12-dev libjpeg-dev libgif-dev libgnutls-dev libxml2-dev </p>
<h3><a class="anchor" id="仅用于终端"></a>
仅用于终端</h3>
<ul>
<li>下载解压同前</li>
<li>./configure &ndash;without-x [&ndash;prefix=/path/to/dir]</li>
<li>make</li>
<li>sudo make install</li>
</ul>
<p>如果你不想自己编译Emacs，从自己的Linux发行版包管理器中进行安装，安装完成后在你的.bashrc或.zshrc中添加：alias em='emacs'这样你就可以像启动vim一样快速启动emacs </p>
<h2><a class="anchor" id="eiiin"></a>
Windows下安装</h2>
<p>从GNU Emacs主页或从http://semantic.supelec.fr/popineau/programming-emacs.html下载最新的64位版本。解压到一个文件夹，并为emacsclientw.exe添加桌面快捷方式。</p>
<h2><a class="anchor" id="fsfadfs"></a>
Mac OS X下安装</h2>
<p>从http://emacsformacosx.com/. 下载编译完成的用于Mac OS X的Emacs，也可以使用https://github.com/railwaycat/emacs-mac-port 处与Mac OS X集成更好的版本。</p>
<h1><a class="anchor" id="swpchae"></a>
切换Ctrl和CapsLock</h1>
<p>如果你使用正规的PC键盘或更好的键盘，通常切换这两个键并不是Emacs的强制要求。但是在手提电脑上情况有些变化。如果在手提电脑上敲代码，我强烈推荐切换这两个键来获得更好的体验。切换这两个键不但是为了提升你的体验，总的来说也是有益的，因为Ctrl通常比CapsLock使用频率高，常用的shell如Bash或Zsh常使用Ctrl快速移动光标。</p>
<p>...这部分的链接需要翻墙，省略了</p>
<h1><a class="anchor" id="concepts"></a>
概念</h1>
<h2><a class="anchor" id="comdf"></a>
命令</h2>
<p>Emacs中所有的用户交互都是函数执行。按键输入字符，Emacs会运行self-insert-command。Emacs里面有两种类型的函数：</p>
<ul>
<li>常规函数：像其他编程语言中的函数，用于实现Emacs功能。用户无需关心这些函数，除非想要实现什么功能或修改现有功能</li>
<li>命令：像函数，但是交互式的。Emacs中命令是提供给用户的功能用户可以直接使用他们。execute-extended-command与M-x绑定。 </li>
</ul>
<h2><a class="anchor" id="Emacs按键标记"></a>
Emacs按键标记</h2>
<ul>
<li>C- 按住Control键</li>
<li>M- Alt键</li>
<li>S- Shift键</li>
<li>DEL Backspace键，Emacs中DEL写作&lt;backspace&gt;</li>
<li>RET 回车键</li>
<li>SPC 空格键</li>
<li>ESC Escape键</li>
<li>TAB TAB键 </li>
</ul>
<p>C-M-x表示按下x键之前同时按住Ctrl和Alt键，从现在开始我不会再说“按下M-X”，如我说C-x C-f your files你应该在你的大脑中find-files命令替换C-x C-f，不用担心，所有的命令都是用动词。通过键绑定回想对应的命令，有助于快速的适应Emacs。例外：如果key是键盘上的一个按键，我会说按下key。如果你看到M-x command，表示你应该同时按下Ctrl和Alt后输入command。</p>
<p>前缀键是全键绑定的一部分，如全键绑定C-x r l用于运行命令bookmark-bmenu-list中C-x和C-x r是他的前缀键。记住键续【如C-x和M-x】倍看做一个字符，了解了前缀键非常方便：如果你忘记了一些使用相同前缀键的命令的键绑定，但是记住了前缀，你可以输入前缀键后按下C-h得到使用这个前缀的命令的列表。如C-x r在emacs中是register和bookmark的前缀，但是你忘记了其中的一个键绑定，输入C-x r C-h可以列出所有前缀为C-x r的绑定。</p>
<p>最后，C-g执行命令keyboard-quit取消所有在执行的Emacs命令。如果不小心按错了键，可以使用C-g取消，然后重新输入。随着学习的深入你会觉得键绑定非常系统和便于记忆。当你看到以n和p结尾的键绑定时，通常表示下一个和前一个；o表示open，h表示help；C-h是命令帮助的标准前缀；键绑定o和C-o经常用于内建工具如Dired，Ibuffr，Occur等。</p>
<h2><a class="anchor" id="easnfisfd"></a>
易于记忆的Emacs键</h2>
<p>键绑定有一些简单容易记住的规则：</p>
<ul>
<li>C-x前缀用于Emacs中默认和全局的键绑定</li>
<li>C-c前缀用于用户自定义</li>
<li>C-u前缀用于改变行为的命令。一个命令可能由于你按下C-u的次数不同展现不同的行为。通常你必须点击C-u一次。</li>
<li>C-&lt;number&gt; 如C-1，C-2等与C-u类似，但是将一个数字传递给命令。通常这个数字表示你想重复执行命令的次数。 </li>
</ul>
<p><a href="Prefix Arguments">前缀参数</a>部分将会对C-u和C-&lt;number&gt;进行介绍，大多数的命令可以使用易于记忆的方式进行组织。如命令helm-do-grep（Enacs第三方插件扩展Helm的命令）可以使用类似C-c h g的键绑定，h代表Helm，g代表grep，可见键绑定并不难于记忆。 </p>
<h2><a class="anchor" id="ingnafdsfa"></a>
使用Emacs内置帮助</h2>
<h3><a class="anchor" id="fhshsadfjsa"></a>
内建帮助系统</h3>
<p>我将根据我的经验介绍一些最有用的命令，我不会全部列出，因此你需要借助Emacs获得你想知道的信息。</p><ul>
<li>C-h m代表describe-mode用于查看当前缓冲区主模式和次模式的键绑定和文档。</li>
<li>C-h w代表where-is，用于获取哪个键命令触发给定的命令；</li>
<li>C-h c代表describe-key-briefly用于查找哪个命令绑定到一个key，如输入C-h c后输入C-x C-f输出find-files。</li>
<li>C-h k代表describe-key查找哪个命令绑定到一个key，同时输出命令文档，如果想知道如何使用一个命令可以使用这个命令</li>
<li>C-h e代表view-echo-area-message用于查看回显区的日志</li>
<li>C-h v代表describe-variable要求输入一个变量，可以输入TAB进行补全，这个命令非常重要，因为通过描述一个变量你可以自定义Emacs和第三方插件的行为。但是现在你不需要进行了解</li>
<li>C-h C-h代表help-for-help如果想看到可用的命令列表可以使用该命令，记住如果你记住了命令绑定的一部分，仅需要输入尽可能多的你想到的部分然后输入C-h，Emacs将输出那个前缀所有的命令，C-h也不例外。C-h C-h仅仅返回所有的键绑定和C-h为前缀的命令。 </li>
</ul>
<h3><a class="anchor" id="infoanfds"></a>
Info</h3>
<p>M-x info或C-h i用于查看Emacs中所有的Info手册，读完我的系列手册后，你可以使用该命令查看Info中的官方手册加深对Emacs的了解。M-x info-emacs-manual 或 C-h r 或&lt;f1&gt; r用于打开emacs手册，当想要学习Emacs的某一部分时，请经常使用Info，早日用它形成读文档的好习惯，你将获得意想不到的收获。 </p>
<h3><a class="anchor" id="fdfgdusnd"></a>
Man</h3>
<p>可以使用两个命令打开Man页面</p><ul>
<li>M-x man 在一个缓冲区中打开一个UNIX页</li>
<li>M-x woman浏览UN*x主题的man页（不使用外部的Man程序）。也就是说你可以浏览man页面但无需安装man程序，使用上面的命令打开man程序 </li>
</ul>
<h2><a class="anchor" id="fdgfdspoutn"></a>
点</h2>
<p>点代表当前指针的位置，从现在开始我会说点而不是当前光标位置 </p>
<h2><a class="anchor" id="gkdakjsopwef"></a>
打开文件</h2>
<p>让我们学习一个非常方便的命令。M-x find-,按TAB将会看到find为前缀的一系列命令。选择find-file，可以点击列表或者继续输入剩下的字符并按下TAB直到命令完整，然后按下回车。快速运行这个命令可以使用键绑定C-x C-f。可以使用通配符选择多个文件，例如假设文件夹里面有下面这些文件：</p><ul>
<li>file_a_1.c</li>
<li>file_a_2.c</li>
<li>file_a_3.c</li>
<li>file_b_1.c</li>
<li>file_b_2.c</li>
<li>file_b_3.c </li>
</ul>
<p>在find-file提示时，可以输入：file*.c打开所有的扩展名为.c的文件。你也可以通过输入：*a*.c选择文件名中包含a的文件，你也可以通过输入：*1.c打开文件名中有1扩展名为.c的文件。通常通配符*可以接受任何字符。实验过程中如果出现类似输入出错的问题可以通过按下C-g解决。</p>
<p>刚才的命令用于浏览和打开文件，与常规编辑器打开类似，但是不是使用鼠标操作，而是使用键盘，这样会更快。如果你使用find-file打开一个在很深的路径下的文件，然后输入回车，将会打开该文件，如果文件不存在，将会创建一个新文件，一个命令两个特征，就是这么神奇。常规编辑器中，如果你先打开一个文件，但是你又想在那里创建一个文件，你必须先把路径切换回去然后使用新见文件命令。另一个有意思的命令是find-file-at-point，如果在point处有一个文件路径或者文件，M-x ffap将会直接打开这个路径或文件。</p>
<center> <div class="image">
<img src="ffap.gif" alt="ffap.gif"/>
</div>
 </center><p> 就像例子中一样，如果point处的路径路径不存在，ffap将会尝试父目录知道路径存在，例子中只有/home/路径存在，并出现在提示符中。 </p>
<h2><a class="anchor" id="jfjghgjgkjdi"></a>
Ido模式</h2>
<p>Emacs有一个有趣的特征叫做Ido（Interactively Do Things缩写）， 本质上，与简单的提示相比，Ido是一个Emacs中交互选择内容的高级接口。通过M-x ido-mode可以激活这个模式，我们使用C-x C-f打开一个文件，你看到： </p><center> <div class="image">
<img src="find-file-normal.gif" alt="find-file-normal.gif"/>
</div>
 </center><p> 或 </p><center> <div class="image">
<img src="find-file-ido.gif" alt="find-file-ido.gif"/>
</div>
 </center><p> 哪一个好点？一旦启用，Ido命令用于大多数要求你从列表中选择的命令中。需要注意以下几点：</p><ul>
<li>如果想使用通配符表达式，不行通过C-f临时还原为普通的查找文件</li>
<li>如果想使用C-x d选择当前路径。将会触发Dired文件管理打开路径并在当前路径中列举文件。后面将要学习Dired，当前如果你打开路径，可以通过C-x k后回车关闭当前列表</li>
<li>在find-file提示后面通过按下回车键选择一个路径，而不是像普通find-file那样使用TAB。 </li>
</ul>
<p>不管怎样，存在一个替代的自动完成和缩小的接口，可以说更强大，但是必须安装一个第三方软件包。这个包叫做Helm。但是本文剩余的部分仍然使用Ido。 </p>
<h2><a class="anchor" id="jkdfjgsklbuff"></a>
缓冲区</h2>
<p>缓冲区是编辑文件内容的地方，临时存放文件内容。只有你明确的调用save-buffer命令的时候所有输入到缓冲区中的内容才会写入到文件。C-x C-s执行保存缓冲区命令，可以使用C-x C-s保存文件，亦可以使用M-x前缀的命令,C-x C-w命令用于文件另存为操作；C-x k命令用于关闭一个缓冲区，直接回车将直接关闭当前缓冲区，也可以输入提示的缓存区名称关闭特定缓冲区。前面我说Point在你的文件中，其实point在缓冲区中，从现在开始将文件和缓冲区当做两个概念，文件指物理文件，缓冲区指临时显示的文件内容。按下C-x b尝试熟悉缓冲区切换命令： </p>
<h2><a class="anchor" id="jagjamajor"></a>
主要模式</h2>
<p>主要模式提供了处理特定文件类型的专用工具，如编程语言语法高亮。主要模式互斥，每一个缓冲区任何时刻只能有一个主要模式。Emacs中提供了多种主要模式用于编辑诸如C、C++、Java、Lisp、bash、asm等不同的编程语言。比如打开以.c作为扩展名的文件，Emacs自动将其识别为C文件并选择C主要模式来高亮缓冲区中的属性。</p>
<h2><a class="anchor" id="nfjgjgmini"></a>
次要模式</h2>
<p>次要模式是可选的可以选择打开或关闭的模式，不明确指定文件或缓冲区的类型。如自动填充模式是一个次要模式，该模式下输入过程中SPC在单词键换行，次要模式之间互相独立，也和选定的主要模式无关。</p>
<h2><a class="anchor" id="fksjabasic"></a>
基本缓冲区管理</h2>
<p>现在已经知道了如何打开文件创建其缓冲区。有些编辑器中有tab页的概念，每次你打开一个文件，你将得到一个tab用于选择正在打开的文件（Emacs中称作缓冲区）。如果你打开多个文件这很快就会变成一个令人烦恼的问题。如果你使用多行文件tab支持将会占用你的编辑空间。如何切换打开的缓冲区呢？C-x b开启一个提示用于输入缓冲区名称，可以像在C-x C-f中补全文件名那样使用Tab补全缓冲区名称。</p>
<p>打开一个文件，并且point在该缓冲区中，C-x C-f提示当前路径，你可以打开当前路径下的文件。举例：缓冲区A来自~/dir1/缓冲区B在 ~/dir2/,point在缓冲区A中，C-x C-f始于~/dir1/；如果point在缓冲区B，C-x C-f始于~/dir2/</p>
<p>一个Emacs会话中，你可以有多个缓冲区，包括诸如shell缓冲区，email缓冲区等无文件缓冲区，当缓冲区的个数非常多的时候，如何进行管理？C-x C-b执行list-buffers将会提供一个可以搜索的缓冲区列表。然而list-buffer仅仅是一个简单的缓冲区管理命令。Emacs还提供了ibuffer，是一个更高级的替代方案。你肯定想使用ibuffer，但让我们先用ibuffer替换list-bufers（通过在~/.emacs中添加如下指令） </p><pre class="fragment">(global-set-key (kbd "C-x C-b") 'ibuffer)
</pre><p> 修改完成后务必保存到*scratch*缓冲区然后执行M-x eval-buffer使修改生效。接下来我们将学习ibuffer </p>
<p>练习:</p><ul>
<li>首先打开不同扩展名的文件，安装用的Emacs源码是一个不错的选择，如果你使用的是二进制文件，可以下载并解压源码包。假设你下载并解压到了~/Downloads/emacs-24.3</li>
<li>C-x C-f切换到emacs-24.3/lisp/打开所有的lisp文件：*.el。如果使用Ido，不要忘了输入到提示区之前使用C-f</li>
<li>C-x C-f切换到emacs-24.3/src/打开所有的C文件：*.c</li>
<li>通过C-x C-b打开缓冲区列表，你将看到一个庞大的缓冲区列表。 接下来有趣的事情要开始了</li>
<li>假设你想处理C代码,输入/ m 并输入一个主要模式来选择属于这个主要模式的缓冲区。前缀/在ibuffer中分组过滤命令。TAB用于查看主要模式列表: <center> <div class="image">
<img src="ibuffer-filter-major.gif" alt="ibuffer-filter-major.gif"/>
</div>
 </center></li>
<li>输入c-mode</li>
<li>只剩下了C缓冲区。但是你用两种主要模式打开了缓冲区：C模式和emacs-lisp-mode，可以通过/ g为每一种模式创建一个组，仅在执行任意过滤命令后执行/ g</li>
<li>现在，过滤仍然有效，按下/ /消除之前的过滤回到完整的缓冲区列表</li>
<li>我们用过滤创建另一个分组，/ m然后输入emacs-lisp-mode，使用/ g创建另一个分组并给它起一个名字。从现在开始，只要你打开一个文件，如果它满足指定的过滤条件，这个缓冲区就会归入特定的分组中。</li>
<li>使用o或者C-o打开一个缓冲区，o打开一个缓冲区并切换point到上面，C-o保持point在缓冲区列表上。让我们用o和C-o打开一个缓冲区，要想切换到其他的缓冲区使用C-x o，改组合执行other-window命令，这个命令在缓冲区中进行遍历（专业一点说缓冲区在Emacs的窗口中，我们是在窗口中遍历，我们后面就会明白）。</li>
<li>使用o或C-o会在下面创建另一个缓冲区，得到两个水平的缓存区。如果你有一个很大的屏幕，你可能不喜欢这种样式。你可以用o、C-x o切换回列表并使用C-x 1关闭另一缓冲区，如果你打开了多个缓冲区，C-x 1关闭活跃缓冲区（point所在的那个也就是缓冲区列表）之外的全部其他缓冲区。使用C-x 0关闭活跃缓冲区。C-x 3在活跃缓冲区右侧创建一个竖直的缓冲区，这将创建一个和活跃缓冲区一模一样的缓冲区。现在在C缓冲区输入o，point将会到那个缓冲区中： <center> <div class="image">
<img src="c-x-3.gif" alt="c-x-3.gif"/>
</div>
 </center></li>
<li>在缓冲区中进行编辑，切换回ibuffer并按下g，将会运行ibuffer-update刷新缓冲区，你会看到刚编辑的缓冲区出现一个危险提示，这表示这个缓冲区已经被修改。</li>
<li>你也可以通过m标记一个缓冲区，然后执行不同的操作： <ol>
<li>
View：按下A查看标记的缓冲区  </li>
<li>
Save：按下S保存标记的缓冲区  </li>
<li>
close： 按下D关闭标记的缓冲区  </li>
<li>
revert：按下V放弃标记缓冲区中的改变  </li>
</ol>
</li>
<li>按下u取消缓冲区的标记</li>
<li>其他打开缓冲区的方式：e（enter）,f(find)或回车清除并使用选择的缓冲区替代列表。使用C-x C-b再次切换到列表. </li>
</ul>
<p>总的来说我将列举这部分你使用的键绑定和其他有用的键绑定：</p><ul>
<li>C-x C-b打开ibuffer</li>
<li>o或C-o打开point处的缓冲区</li>
<li>e, f 或回车用缓冲区替换缓冲区列表</li>
<li>= 比较当前缓冲区中的内容与对应的文件 小贴士：当point在一个入口时，C-x C-f在入口的缓存区所在的路径开始</li>
<li>过滤命令 <pre class="fragment">/ m 通过主要模式增加过滤
/ n 通过缓冲区名称增加过滤
/ c 通过缓冲区内容增加过滤
/ f 通过文件名增加过滤
/ &gt; 通过缓冲区大小增加过滤
/ &lt; 通过缓冲区大小增加过滤
/ / 移除所有的过滤
</pre></li>
<li>过滤组命令： <pre class="fragment">/ g 从过滤中创建一个过滤组
TAB 移动到下一个过滤组
M-p 移动到上一个过滤组
/ \ 移除所有活动的过滤组
/ S 保存并命名当前组
/ R 恢复之前保存的组
/ X 删除之前保存的组
</pre></li>
<li>排序命令： <pre class="fragment">, 切换排序模式
s i 反续当前的排序模式
s a 按字母系列排序缓冲区
s f 按文件名称排序缓冲区
s v 按最后访问时间排序缓冲区
s s 按大小排序缓冲区
s m 按主要模式排序缓冲区
</pre></li>
<li>按q退出iBuffer </li>
</ul>
<h2><a class="anchor" id="jfkboskgdfjag"></a>
书签：跨Emacs会话保存位置</h2>
<p>读书的时候，通常不能一次读完，我们会放置一个书签供以后继续往下读。Emacs也允许你放置书签： </p><pre class="fragment">C-x r m 命令: bookmark-set在point处设置书签，执行该命令会要求你输入一个名称，输入名称后回车；
C-x r b 命令: bookmark-jump 跳转到一个保存的书签，按TAB得到书签列表
C-x r l 命令: bookmark-bmenu-list 打开所有书签列表
</pre> <p>键绑定非常简单，你只需记住C-x r是书签相关的命令前缀，m表示标记，表示在某处标记某物；b表示书签，你可以快速跳转到任意书签，就像C-x b可以快速在缓冲区间切换。最后，l代表list表示列出书签同比ibuffer的列出缓冲区，如果想跨会话保留书签，C-x r l打开书签列表，然后按下s保存列表到文件。如果你知道如何管理缓冲区，管理书签也一样，使用不同但是类似的键绑定，你不但可以标记与文件相关联的缓冲区，你也可以标记非文件缓冲区：</p><ul>
<li>Dired 缓冲区</li>
<li>Info 缓冲区</li>
<li>Man页面 </li>
</ul>
<p>bookmark-bmenu-list列表下一些有用的键绑定： </p><pre class="fragment">RET 打开书签，打开书签后可以通过C-x r l回到书签列表
1   打开一个书签关闭其他缓冲区
n   切换到下一个入口
p   切换到上一个入口
s   把当前的书签列表保存到文件中
o   在另一个窗口中打开书签并将point设置在上面，如果想做对比C-x 3打开一个竖直的缓冲区书签将会在竖直的缓冲区中打开
C-o 与o类似，但是point仍然在书签列表中
r   重命名point处的书签
m   标记显示point处的书签
v   显示所有标记的书签
d   给书签设置删除标记
x   删除标记过的书签
u   取消标记或标志过的书签
</pre><p> 练习:</p><ul>
<li>打开一个文件并创建几个书签。使用C-x r b在这些书签间切换</li>
<li>C-h i 打开Info，选择一个节点不停地点击进入，标记书签然后关闭当前Info缓冲区</li>
<li>C-x r l 打开书签列表练习表中的键绑定</li>
</ul>
<h2><a class="anchor" id="fhjsahgksakiji"></a>
基础跳转命令</h2>
<p>这些键绑定也被诸如bash或zsh等大众化的shell所使用，强烈建议掌握这些键绑定：</p><ul>
<li>向前移动一个字符：C-f （f代表forward）</li>
<li>向后移动一个字符：C-b （b代表backward）</li>
<li>向上移动一行：C-p （p代表previous）</li>
<li>向下移动一行： C-n （n代表next） 上面的操作也可以使用方向键，如果不想使用上面的键绑定，方向键也可以达到相同的效果</li>
<li>移动到行首：C-a</li>
<li>移动到行尾： C-e</li>
<li>向前移动一个单词：M-f</li>
<li>向后移动一个单词：M-b 这些键绑定只存在于Emacs中：</li>
<li>向上滚动一屏：C-v， page down</li>
<li>向下滚动一屏：M-v， page up</li>
<li>跳转到句首：M-a</li>
<li>跳转到句尾：M-e</li>
<li>Recenter（使当前行point到屏幕中间）屏幕：C-l</li>
<li>将point重置到当前屏幕的顶部、中间和底部：M-r</li>
<li>移动到缓冲区顶部：M-&lt;</li>
<li>移动到缓冲区尾部：M-&gt;</li>
<li>移动到缓冲区第n个字符：M-g c（c代表character）</li>
<li>移动到缓冲区第n行：M-g l（小于23.2版本），M-g g（大于等于23.2）（l/g代表line） 练习： 使用键绑定执行上面的命令至少10次或者直到掌握为止；这些移动命令可以在任意缓冲区执行。 </li>
</ul>
<h2><a class="anchor" id="fjakhgsadfkjkjdfisj"></a>
有用的内置导航对键绑定</h2>
<ul>
<li>C-M-f绑定命令forward-sexp，通过一个平衡表达式（如匹配括号等）向后移动。例子： <center> <div class="image">
<img src="forward-sexp.gif" alt="forward-sexp.gif"/>
</div>
 </center></li>
<li>C-M-b绑定命令backward-sexp，通过一个平衡表达式（如匹配括号等）向前移动。例子： <center> <div class="image">
<img src="backward-sexp.gif" alt="backward-sexp.gif"/>
</div>
 </center></li>
<li>C-M-k 绑定命令 kill-sexp,通过平衡表达式向后删除。例子： <center> <div class="image">
<img src="kill-sexp.gif" alt="kill-sexp.gif"/>
</div>
 </center></li>
<li>C-M-t 绑定命令 transpose-sexps, 转置表达式。例子： <center> <div class="image">
<img src="transpose-sexp.gif" alt="transpose-sexp.gif"/>
</div>
 </center></li>
<li>C-M-&lt;SPC&gt; or C-M-@ 绑定到 mark-sexp,在后面的表达式后面设置标记。例子： <center> <div class="image">
<img src="mark-sexp.gif" alt="mark-sexp.gif"/>
</div>
 </center></li>
</ul>
<h2><a class="anchor" id="jfasdjbaseicae"></a>
基本编辑命令</h2>
<p>Emacs中的kill（清除）等同于其他编辑器中的Cut（剪切）。这些键绑定在终端中也有效：</p><ul>
<li>清除point处的一个字符：C-d</li>
<li>清除整行：C-S-DEL（DEL表示backspace键）</li>
<li>从当前point清除到词尾：M-d</li>
<li>从当前point清除到词首：M-DEL</li>
<li>清除point处的所有空格：M-\</li>
<li>清除point处之外所有的空格：M-SPC</li>
<li>删除本行point后面的内容：C-k</li>
<li>删除整句：M-k 清除内容时，清除的内容将会放置到清除环。编写代码时可以通过M-;快速的添加或去掉注释，如果没有高亮一个区域，M-;将注释添加到行尾，反之会注释掉整个区域 </li>
</ul>
<h2><a class="anchor" id="dsfdynag"></a>
动态缩写</h2>
<p>动态缩写是Emacs中的一个自动补全特征，作用于文本并且独立于上下文。如果你输入了一次单词，如果你再次输入这个单词，你可以只输入一部分后使用M-/补全。如果你输入一个有多个候选的前缀，M-/遍历候选。这是一个你应该尝试一下的很酷的特征。 </p>
<p>练习：</p><ul>
<li>在练习缓冲区中输入 thisIsaVeryVeryVeryVeryLongWord。</li>
<li>添加一个新行或空格</li>
<li>输入 thisIs并按下M-/，不错Emacs为你自动补全了。</li>
<li>在缓存区中输入random后按下M-/。Emacs将提示没有找到动态缩写。</li>
<li>输入 randomword 后添加一个空格，现在输入 random 再次按下M-/。Emacs可以高兴的为你补全random。记住想要让Emacs记住你的单词，你必须输入一个完整的单词 </li>
</ul>
<h2><a class="anchor" id="fsdjkilllring"></a>
清除环</h2>
<p>清除环是之前清除内容的列表，可以通过C-y插入最近一次清除的内容。如果在C-y之前使用C-&lt;number&gt;-&lt;number&gt;(任意数字)将会黏贴清除环中第number个入口，最近的入口是第一个入口。C-1 C-y等同于C-y；C-2 C-y是最近倒数第二个入口，并把那个入口作为列表头等。</p>
<p>让我们在清除环中耽搁一段时间，打开一个缓冲区，输入这三行： </p><pre class="fragment">         aaa
         bbb
         ccc
</pre><p> 然后：</p><ul>
<li>从上到下使用C-k删除这三行；</li>
<li>C-y或C-1 C-y将会看到ccc被插入</li>
<li>C-2 C-y将会看到bbb被插入；再次输入C-y将会看到bbb又一次被插入，bbb现在成为了列表头；</li>
<li>C-2 C-y将会看到aaa被插入；再次输入C-y将会看到aaa又一次被插入，aaa现在成为了列表头；</li>
<li>插入这三行并再次全部清除；</li>
<li>C-3 C-y将会看到aaa被插入；再次输入C-y将会看到aaa又一次被插入，aaa现在成为了列表头;</li>
<li>... </li>
</ul>
<p>C-&lt;number&gt;称作前缀参数。基本上用于改变命令的行为。后面你将还会了解到前缀参数。除了上面的方法可以使用M-y运行yank-pop。默认情况下，C-y插入最近一次清除的内容，如果你想在C-y之后提取更早清除的文本，M-y来遍历清除环中的入口，必须先运行C-y否则M-y不会生效。你可能会想，当清除环异常大的时候会发生什么，怎么知道哪一个在什么位置。这个问题不错，这就是第三方插件的亮点。但是，你可以使用C-h v后输入kill-ring查看清除环，这时你将看到kill-ring的内容，只不过是编码模式既不美观又不友好。</p>
<h2><a class="anchor" id="fkasjgkmarkandregon"></a>
标记和区域</h2>
<p>标记是缓冲区中记录的一个位置，就像你在读书的时候在不同的地方做记录，这些记录叫做书签。与之类似，只不过这里的标记是Emacs在缓冲区中（Emacs中也有书签，但是我们要在后面进行描述）。当你在缓冲区的两点之间做标记的时候，两个位置之间的文本会被高亮。我们称高亮的部分为区域。当区域高亮的时候，我们称区域被激活；想反激活一个区域只要按下C-g或者像在其他编辑器中一样移动point。</p>
<p>练习：</p><ul>
<li>使用C-SPC C-SPC在缓冲区中设置一个标记，我们叫它标记A。</li>
<li>移动到缓冲区的另一个位置，使用C-SPC C-SPC设置另一个标记，称作标记B。</li>
<li>移动到另一个位置，再次使用C-SPC C-SPC称作标记C</li>
<li>按下C-u C-SPC可以看到point回到了标记B</li>
<li>再次C-u C-SPCpoint回到了标记A</li>
<li>再次C-u C-SPCpoint回到了标记C</li>
<li>我们创建一个区域：C-SPC然后向前移动point，发生了什么？</li>
<li>高亮部分称作区域，可以在区域中执行编辑命令： <ol>
<li>
C-w 清除区域  </li>
<li>
M-w 复制区域  </li>
<li>
C-y 粘贴区域  </li>
</ol>
</li>
<li>让我们拷贝或清除一个区域。选择一个较大的区域。把它粘贴到其他的地方，粘贴后你会发现point不在原始位置了，如果你想回到粘贴的地方，执行C-u C-SPC或者C-x C-x. </li>
</ul>
<p>粘贴的时候插入内容之前会在point处创建一个标记。内容插入后point会根据内容大小进行移动，通常大多数Emacs命令创建突然的位移推进标记，所以你可以不用繁琐的滚动整个缓冲区而回到以前的位置。C-x C-x执行exchange-point-and-mark命令用于交换point与使用C-y粘贴时创建的标记位置。自己试验一下，命令执行后由标记和point包围的区域会被激活。使用C-x C-x非常方便，不用逐行高亮来拷贝或清除，你可以这么做： </p><center> <div class="image">
<img src="c-x-c-x.gif" alt="c-x-c-x.gif"/>
</div>
 </center><p> 记住当你需要高亮一个大的区域时不小心失去了高亮，不得不重做，C-x C-x使你避免这个无聊的操作。C-u C-SPC简单的使你回到之前C-y时插入的标记位置。这个命令不会激活区域。持续练习直到你掌握这两个命令。 </p>
<h2><a class="anchor" id="famamarksigroing"></a>
标记环</h2>
<p>一个使你在前面的练习中可以在不同的标记中跳转的标记列表。你可以在列表中循环跳转到标记，或者在扩展包的帮助下得到一个列表交互式选择。Helm就是一个出色的这类的扩展例子。我们后面会详细的讨论扩展包。 </p>
<h2><a class="anchor" id="全局标记环"></a>
全局标记环</h2>
<p>标记环仅在每个缓冲区中有效，如果跳转到其他的缓冲区，你将得到一个新的本地标记环。全局标记环与标记环类似，但是它在缓冲区间持续有效。每当你设置一个标记，这个标记除添加到缓冲区本地的标记环也设置到全局标记环。可以使用C-x C-SPC循环全局标记。 </p>
<h2><a class="anchor" id="jffdgundoredogfjd"></a>
撤销/重做</h2>
<p>撤销：C-/或C-x u </p>
<p>重做：这很难做到，因为你需要了解emacs中撤销是如何工作的，编辑时，emacs跟踪当前编辑文件中的变化，例如，你在文件中插入如下几行： </p><pre class="fragment">aaa
bbb
ccc
</pre><p> Emacs像下面这样跟踪历史：</p><ul>
<li>insert: "aaa"</li>
<li>insert: "bbb"</li>
<li>insert: "ccc" </li>
</ul>
<p>现在执行撤销两次，文件变成了：aaa，文件变化的历史如下：</p><ul>
<li>insert: "aaa"</li>
<li>insert: "bbb"</li>
<li>insert: "ccc"</li>
<li>undo insert: "ccc"</li>
<li>undo insert: "bbb" </li>
</ul>
<p>如何插回bbb和ccc,通过撤销以前的撤销！再仔细观察一下以上的变化历史。您可以看到Emacs会跟踪您最近的撤消操作。执行一些运动命令，例如C-f，然后尝试C-/两次，看看会发生什么。 不错，你把以前的内容bbb和ccc找回来了。这是因为你仅仅撤销了最近的"undo insert:...",当你执行了一系列的撤销操作，中间没有其他命令，Emacs将不停地还原到较旧的内容，当使用其他命令打断撤销序列时，undo insert:... 序列将会插入到文件历史中，又是一个命令，两个特征，不过这次有点混乱。</p>
<p>练习：练习使用撤销/重做，直至习惯。 </p>
<h2><a class="anchor" id="fkdfgaserarcgogso"></a>
文本查找</h2>
<p>所有的编辑器中内容查找是一个关键的特征，Emacs有很多内建工具解决这个问题 </p>
<h3><a class="anchor" id="fiagnasinvere"></a>
增量搜索</h3>
<p>你要在缓冲区中找点什么吗？C-s触发isearch-forward命令，该命令运行你从当前point向前查找内容，按下C-s后你还被提示输入要搜索的内容，输入内容后，重复按下C-s，向前浏览匹配项。与之类似，C-r触发isearch-backward,允许你从当前点向前搜索，重复按下C-r将会向后浏览匹配项。isearch可以在所有有效的缓冲区中被触发，你可以在ibuffer中练习isearch。</p>
<p>练习：打开一个有相当多内容的文件，C-s输入搜索内容后不停地按下C-s。重复几次后，重复按下C-r，发生了什么？你可以使用C-s触发C-r反之亦然跳转到下一个或前一个匹配项，C-g取消当前的搜索会话，将光标移动到一个单词按下C-s，然后C-w，选择从光标到词尾的内容，举例：光标在"Hello world"的e处，C-w将填充ello到C-s提示处，再次按下C-w填充" world"到提示处，搜索信息变成了"ello world",C-g再C-s你可以使用下面的命令选择以前的输入再次搜索：</p><ul>
<li>M-p 跳转到以前的输入</li>
<li>M-n跳转到下一个输入 </li>
</ul>
<p>如果你想使用正则表达式进行搜索，使用C-u C-s命令，现在你已经熟悉了基础的Isearch，有很多有用的命令绑定到了M-s前缀键 </p><pre class="fragment">M-s .   命令: isearch-forward-symbol-at-point 将光标处的符号送到C-s执行搜索的位置
M-s o   命令: occur 运行occur
M-s h . 命令: highlight-symbol-at-point 高亮光标处的符号
M-s h l 命令: highlight-lines-matching-regexp 高亮符合输入表达式的行
M-s h r 命令: highlight-regexp 根据正则表达式高亮
M-s h u 命令: unhighlight-regexp 取消满足正则表达式的高亮
</pre> <h3><a class="anchor" id="fjskdjfkoccue"></a>
Occur</h3>
<p>occur命令列举所有匹配一个字符串或表达式的行并将结果显示在一个称作 *Occur*的缓冲区。当有大量的匹配项并且需要较好的工具来管理而不是仅仅使用iSearch来回检索时，occur非常有用。例如，当在有1000行左右的匹配项时，但是你现在在500行处，在这两行之间有很多其他的匹配项，你不能使用Isearch跳过他们，这个时候*Occur*就非常有用了。*Occur*在查找替换字符串时也很有用，允许你验证是否确实替换了正确的字符串。</p>
<p>允许M-s o触发occur，如果在Isearch提示符下运行M-s o，occure将获取当前使用的文本，是不是非常贴心。可以使用M-g n和M-g p跳转到下一个或上一个匹配项，也可以使用鼠标滚动。如果你觉得M-g n和M-g p来回跑太烦人，可以使用C-x z运行repeat：</p><ul>
<li>M-g n 跳转到下一个匹配项</li>
<li>C-x z 重复上一个命令</li>
<li>从现在开始，保持按下z重复以前的命令直到你按下其他字符 </li>
</ul>
<p>看一个例子，注意看主缓冲区中光标移到的时候*Occur*缓冲区中非激活光标的移动： </p><center> <div class="image">
<img src="occur.gif" alt="occur.gif"/>
</div>
 </center> <p>可以在occur缓冲区中进行操作，在*Occur*缓冲区中使用C-p和C-n跳转到上一个或下一个入口。按下o跳转到光处的匹配并切换光标到包含匹配项的缓冲区；C-o打开光标处匹配项但是不会切换缓冲区。如果想编辑匹配项，按下e进入occur-edit-mode，之后你可以在*Occur*缓冲区的任意地方进行编辑，可以看到输入时在另一个缓冲区的输入更新。在occur-edit-mode下可以执行任意编辑命令，如前面部分中的查找替换来替换所有的匹配。例子： </p><center> <div class="image">
<img src="occur-edit.gif" alt="occur-edit.gif"/>
</div>
 </center> <p>这里是occur中的键绑定： </p><pre class="fragment">C-n 跳转到下一行
C-p 跳转到上一行
&lt;   跳转到缓冲区开头
&gt;   跳转到缓冲区结尾
e   编辑当前的 *Occur* 缓冲区
C-c C-c 编辑完成后，结束编辑模式
g   如果你搜索的文件正在更新，按下g刷新 *Occur*缓冲区，显示改变
o   跳转到匹配项并切换光标位置
C-o 跳转到匹配项保持光标位置在 *Occur*缓冲区
</pre><p> 如果你想得到这个表（或更多的键绑定），可以在*Occur*缓冲区中运行C-h m或按下h，q退出*Occur*缓冲区。 </p>
<h3><a class="anchor" id="cahjadhgchazaoque"></a>
查找替换</h3>
<p>M-执行query-replace进行替换，M-要求两个输入：</p><ul>
<li>需要替换的字符串</li>
<li>替换后的字符串 </li>
</ul>
<p>提供输入后回车,Emacs会要求你确认替换的字符串。如果要替换全部匹配项，按下！不用回答yes或no（注意：仅替换光标后面的匹配项）。使用C-M-用正则表达式进行查找替换。提示：这个命令有点不好按，简单起见，使用两只手：</p><ul>
<li>左手按下（或S-5），右手按下C-M-。</li>
<li>右手先按下C然后左手按下M-% </li>
</ul>
<h3><a class="anchor" id="fjkfmultii"></a>
Multi-occur</h3>
<p>与occur相同只不过它要求输入多个缓冲区。</p><ul>
<li>multi-occur询问搜索的缓冲区。逐个输入缓冲区直到输入空。</li>
<li>multi-occur-in-matching-buffers要求一个正则表达式，在缓冲区中检索符合正则表达式的匹配。 </li>
</ul>
<h3><a class="anchor" id="fakjdgrepffga"></a>
正则表达式</h3>
<p>M-x rgrep允许你使用外部的正则表达式命令搜索文本并在缓冲区中显示搜索结果。在Emacs中使用正则表达式的好处是原始的输出被处理过了，最终的结果被上色并且可以点击，这样你就可以快速的访问匹配的位置。rgrep在根路径为dir的路径树中文件中的正则表达式递归查找。执行rgrep时你将被提示输入这三个参数。使用C-u前缀你可以在执行前编辑结构化的shell命令行，使用两个C-u前缀编辑并运行grep-find-command(这是一个变量)，它是执行rgrep的底层命令。 </p><center> <div class="image">
<img src="grep.gif" alt="grep.gif"/>
</div>
 </center> <p>得到的结果显示在一个名为*grep*的缓冲区，可以点击结果或者使用M-g p和M-g n向后或向前跳转查找结果，即使*grep*缓冲区中的光标没有激活。可以使用下面的键绑定： </p><pre class="fragment">TAB 跳转到下一个匹配项，但不显示匹配缓冲区
S-TAB   跳转到上一个匹配项，但不显示匹配缓冲区
{   跳转到上一个文件，但不显示匹配缓冲区
}   跳转到下一个文件，但不显示匹配缓冲区
C-o 显示匹配位置，但光标不切换到匹配缓冲区（仅在24.3以上版本有效）
n   显示下一个匹配的缓冲区，但不切换光标
p   显示前一个匹配的缓冲区，但不切换光标
M-g n   显示下一个匹配的缓冲区，切换光标到匹配的位置
M-g p   显示前一个匹配的缓冲区，切换光标到匹配的位置
RET 显示匹配位置，切换光标到匹配缓冲区
SPC 向下滚动，等同于C-v
S-SPC   向上滚动，等同于M-v
g   使用上一个执行的命令刷新 *grep* 缓冲区
q   退出 *grep* 缓冲区
</pre> <p>想要获得这些键绑定的列表，在*grep*缓冲区输入？或h或C-h m，如此庞大的一个键绑定列表，不过不用担心，这些键绑定在其他Emacs实用程序中非常普遍，你可以重用这些键绑定。 </p>
<h2><a class="anchor" id="nfsmodeline"></a>
模式栏</h2>
<p>模式栏是缓冲区下面的空白区域。它包含了显示在窗口中的缓冲区的相关摘要信息。显示在模式栏中的文本使用下面的格式： </p><pre class="fragment">cs:ch-fr | buf | pos line | (major minor)
</pre> <p>举个例子，模式栏长得像这样： </p><center> <div class="image">
<img src="modeline.jpg" alt="modeline.jpg"/>
</div>
 </center> <p>cs描述缓冲区中文本的字符集类型，看到图中的字符U了吗？表示你的文本使用UTF-8编码系统。如果使用不同的语言输入，并且输入法打开了，U的左侧将会出现那种语言的符号，即\U,反斜杠表示文本输入法，C-\提示你选择一种语言，选择完成后，后一个C-\表示打开或关闭输入法选择。可以使用M-x set-input-method再次设置输入法。ch描述当前缓冲区的编辑状态：</p><ul>
<li>如果缓冲区中的文件内容与对应的文件一致，也就是说缓冲区没有被修改将会显示两个破折号（‘-’）</li>
<li>如果缓冲区被修改了，显示两个星号（‘**’），只读缓冲区被修改后显示%*，反之显示%，图中的缓冲区被修改过了。 </li>
</ul>
<p>fr中给出选中的frame名称，frame在你的操作系统中是一个Emacs窗口，如下面这两个Emacs的frame： </p><center> <div class="image">
<img src="frames-gui.gif" alt="frames-gui.gif"/>
</div>
 </center> <p>如果你使用的是GUI版本的Emacs，他将一直是一个破折号，然而如果你在终端中使用Emacs，你不能像上面的截屏一样拥有多个frame窗口，取而代之的是Emacs使用类似F1，F2...Fn命名的虚frame，注意看我的鼠标指针： </p><center> <div class="image">
<img src="frames-term.gif" alt="frames-term.gif"/>
</div>
 </center> <p>buf是缓冲区名称，通常为文件名，但他们可以有不同的名字。pos显示浏览屏幕的当前位置，如果从第一行浏览，这里将显示Top，如果在缓冲区的最后一行，这里显示Bottom，否则显示百分比位置，例如20表示浏览位置距离顶部占全部的20。line显示当前的行号，major显示当前的主要模式，minor显示次要模式。 </p>
<h2><a class="anchor" id="miniminifngd"></a>
迷你缓冲区</h2>
<p>迷你缓冲区是Emacs底部较小的部分。这里是Emacs命令读取复杂参数（如文件名，缓冲区名，Emacs命令名，或Lisp表达式）的地方，当你执行find-file命令时，Emacs将会在迷你缓冲区中要求你输入文件名，这是该命令需要的一个参数。记住我在前面说过Emacs中一切都是函数。find-file是一个命令，换句话说它是一个交互函数，作为一个函数，它需要一个参数。迷你缓冲区是将参数提供给交互函数的地方。</p>
<p>迷你缓冲区中有输入历史。在迷你缓冲区中输入内容后回车，迷你缓冲区会记住这个输入，你可以这样再次获取输入内容：</p><ul>
<li>M-p 移动到迷你缓冲区的上一个输入</li>
<li>M-n 移动到迷你缓冲区的下一个输入</li>
<li>M-r 搜索匹配提供的正则表达式的一个输入 这在任意从迷你缓冲区获得输入的命令中有效，就像你在Isearch中用M-p和M-n获得之前的输入一样。 </li>
</ul>
<h2><a class="anchor" id="fjsghsgsecho"></a>
回显区</h2>
<p>迷你缓冲区也可以用作输出,回显区域用于显示使用消息原语生成的消息，以及回显击键。 迷你缓冲区和回显区尽管作用不同，它们共享同一个物理区域，不要在这两者之间搞混。 </p>
<h2><a class="anchor" id="fgframenn"></a>
Frames</h2>
<p>Emacs称操作系统中的应用程序窗口为frame。在命令行中执行并打开Emacs那个frame承载了Emacs会话。Emacs可以有多个frame装载Emacs的不同部分，例如一个分割frame装载迷你缓冲区。早些时候我只使用了一个frame，但是如果你想把缓冲区规划到不同的组中frame会非常有用。比如每一个frame可以是一个工程，F1 frame容纳我的C编编码工程的缓冲区， F2 frame容纳自定义Emacs相关的缓冲区，F3 frame容纳email、阅读、新闻组等相关的缓冲区。如前所述，多个frame在终端下为每一个frame给一个名字F1,F2...Fn。操作多frame的键绑定有： </p><pre class="fragment">C-x 5 C-f   命令: find-file-other-frame 在不同的frame中打开一个文件
C-x 5 f 命令: find-file-other-frame 同 C-x 5 C-f
C-x 5 C-o   命令: display-buffer-other-frame 在不同的frame中打开一个缓冲区，并将光标移到上面
C-x 5 . 命令: find-tag-other-frame 在不同frame的光标处查找标记
C-x 5 0 命令: delete-frame 销毁光标所在的当前frame
C-x 5 1 命令: delete-other-frames 销毁光标不在其中的frame
C-x 5 2 命令: make-frame-command 创建一个frame
C-x 5 b 命令: switch-to-buffer-other-frame 同 C-x 5 C-o
C-x 5 d 命令: dired-other-frame 在另一个frame中打开Dired缓冲区
C-x 5 m 命令: compose-mail-other-frame 打开另一个frame用于写email
C-x 5 o 命令: other-frame 在所有的frame中跳转
C-x 5 r 命令: find-file-read-only-other-frame 在另一个frame中以只读方式打开文件
</pre> <h2><a class="anchor" id="fsjsakjfsfwindows"></a>
Window</h2>
<p>与其他编辑器不同，Emacs可以划分frame为多个较小的区域。每一个小区域叫做一个Window。你可以划分frame为任意多个window，每个window中可以有任意内容。如你当前的编辑缓冲区，文件管理缓冲区，帮助缓冲区，shell等，基本上Emacs可以显示的一切，我们试试看，练习： </p>
<p>C-x 2 分割当前window为两个水平窗口。分割后，你将获得当前编辑缓冲区的拷贝。split-window-below 绑定到C-x 2。 C-x 3分割当前window为两个竖直窗口。分割后，你将获得当前编辑缓冲区的拷贝。split-window-right绑定到C-x 3</p>
<p>现在执行完上面的两个命令后，你将得到三个窗口。每一个window容纳一个缓冲区。使用上面的两个命令你可以创建任意的窗口布局。Emacs中窗口布局称作窗口配置。C-x执行命令other-window在窗口间导航，试着在窗口间跳转几次来适应它。Emacs中&lt;next&gt;为下一页键，&lt;prior&gt;为上一页键。M-&lt;next&gt;运行scroll-other-window并向前滚动其他窗口。M-&lt;prior&gt; 运行 scroll-other-window-down并向后滚动其他窗口，其他窗口指你使用C-x o访问的窗口。</p>
<p>C-x 0 关闭point处的window，C-x 1 关闭当前未选中的其他窗口，创建一个窗口然后实验一下C-x 1。C-x 4为在其他缓冲区中打开对象的命令前缀，这里的对象可以是文件、shell或浏览树，这些是标准的C-x 4绑定： </p><pre class="fragment">C-x 4 C-f 命令: find-file-other-window 与前面讨论的find-file类似，只不过这个命令在一个新窗口中打开。如果当前frame只有一个window，将会创建一个新的window。
C-x 4 C-o 命令: display-buffer 从缓冲区列表中选择一个缓冲区并在另一个window中显示，不过不会将point移动到那个窗口。
C-x 4 . 命令: find-tag-other-window 在另一个窗口的point处打开一个标记（后面详述）。
C-x 4 0 命令: kill-buffer-and-window 与C-x 0类似，不过还会清除那个window中的缓冲区。
C-x 4 a 命令: add-change-log-entry-other-window 打开另一个缓冲区，允许你记录当前编辑文件的变化。这些天，你使用版本控制系统管理文件变化，Emacs做得更好。或许这个特性在诸如git这些工具出现之前就已经存在了。
C-x 4 b 命令: switch-to-buffer-other-window 在其他窗口中打开一个选中的缓冲区，并将point移动到那个窗口。
C-x 4 c 命令: clone-indirect-buffer-other-window 在其他窗口中克隆当前的缓冲区，并给他一个不同的缓冲区名字。
C-x 4 d 命令: dired-other-window 在另一个窗口中打开一个dired缓冲区，Dired是一个Emacs内建的文件管理，我们将在后面讨论。
C-x 4 f 命令: find-file-other-window 与C-x 4 C-f
C-x 4 m 命令: compose-mail-other-window 在另一个窗口中写邮件，你可以从Emacs中写邮件并直接发送。
C-x 4 r 命令: find-file-read-only-other-window 类似find-file-other-window，不过以只读方式打开。
M-\&lt;next\&gt;  命令: scroll-other-window 向前滚动其他窗口
M-\&lt;prior\&gt; 命令: scroll-other-window-down 向后滚动其他窗口
</pre> <p>这是一个非常长的表？如果你忘了，你可以：</p><ul>
<li>再次访问我的手册 ：）</li>
<li>或更快一些，使用Emacs迷人的帮助系统直接从Emacs获取。因此，如果你想知道C-x 4为前缀的所有键绑定，只需按下C-x 4后按下C-h。如果你输入一个前缀键后按下C-h，将会列出所有以其为前缀的键绑定和命令，与其他编辑器将所有信息深藏在菜单布局中相比，这非常友好。后面的部分将会讨论帮助系统。 </li>
</ul>
<h2><a class="anchor" id="pfkfsdfgarg"></a>
前缀参数</h2>
<p>Emacs背后函数无所不在，函数可以接收参数，还可以传递参数到Emacs命令中来改变它的行为。然而，你不用写代码传入参数调用一个函数然后编辑运行。你可以用交互的方式传递参数。练习：</p>
<p>稍早的时候你学习了诸如C-f，C-b，C-p和C-n的移动命令，还记得吗？但是使用C-f你每次只能向前移动一个字符，使用C-b向后移动一个字符，使用C-p向前移动一行，使用C-n向后移动一行。现在试试在前面那些命令输入之前执行C-4，看到什么变化了吗？不错，不是执行了一次（如向前移动一个字符...）,重复执行了4次（即向前移动了四个字符...）。许多命令允许通过前缀参数重复执行多次。</p>
<p>你甚至可以传递负前缀参数，试着使用C-4执行上面的命令，不错Control和减号和4（-4）。看到没有，命令也是执行了4次，但是是反向执行，就是说执行C-f不是向前移动4个字符，而是向后移动4个字符。你可能疑惑为什么和C-4 C-b不同，但是，许多命令没有反向的版本，因此负参数在这种情况下总是有用的。</p>
<p>现在执行一下C-4 u C-f将会看到与C-4 C-f做了相同的事。再次，为什么我们需要C-u？这是因为在终端中不能使用Control加数字键，C-u告诉Emacs你要输入一个数字，它将准备好接收输入。只不过是不同的实现路径。如果不提供任何前缀参数，如你直接执行C-u C-f那么默认的数字参数为4，试一下C-u C-f，可以看到向前跳转了4个字符。试几次熟悉这个流程。如果不停地执行C-u，数字参数是4的乘方，执行一次C-u结果参数是4的一次方，C-u C-u结果是4的平方即16，C-u C-u C-u结果是4的三次方即64，大的幂次方难以计算，但是有一个插件显示计算和这些数字。这个插件是Helm，但是我将在第二部分进行介绍。为什么4是C-u的参数我也不知道。</p>
<h2><a class="anchor" id="kfsbasecidi"></a>
使用Dired进行基本的文件管理</h2>
<p>Emacs有一个内置的文件管理叫做Dired，（Dir)ectory (Ed)itor的缩写。这部分是GNU Emacs中对dired介绍的缩减版本，读完并试用这些命令后，如有需要可以参考Dired 手册。 </p>
<h3><a class="anchor" id="fsdfjkengtr"></a>
进入Dired</h3>
<pre class="fragment">C-x d   选择一个路径并在这个路径下开始Dired
C-x 4 d 选择一个路径并在另一个windows中开始Dired
C-x C-f 选择一个路径入Dired
</pre> <p>练习：执行上面的命令直至掌握，你最喜欢哪一个？ </p>
<h3><a class="anchor" id="fasjfnaviga"></a>
导航</h3>
<pre class="fragment">n   移动到point下面的一个入口
p   移动到point上面的一个入口
C-s 使用Isearch搜索文本，在Dired中搜索入口非常有用
</pre> <p>你可以为这些命令提供前缀命令，如4 n移动到后面4行的入口。使用带前缀参数或不适用前缀参数的方式练习上面的命令。 </p>
<h3><a class="anchor" id="fjsakdfjcerea"></a>
新建文件</h3>
<p>使用C-x C-f和C-x 4 C-f的方式在Dired中创建一下新文件。 </p><pre class="fragment">+   提示一个路径名并在回车后创建。
C-x C-f 创建一个文件，常规的find-file
</pre><p> 练习：</p><ul>
<li>创建一个名为dired_practic的路径，也可以是你喜欢的名字</li>
<li>创建一个新文件 </li>
</ul>
<h3><a class="anchor" id="fsfgfcaif"></a>
文件访问</h3>
<pre class="fragment">f or e or RET   打开光标处的文件
o   在另一个window中打开光标处的文件
C-o 在另一个window中打开光标处的文件，但不要跳转光标
v   以只读方式打开文件
^   打开父路径并创建父路径的Dired
</pre><p> 练习：</p><ul>
<li>假设你在前面部分新创建的路径下面；</li>
<li>使用^跳转到父路径</li>
<li>打开另一个路径，进入那个路径，将会创建一个缓冲区列举路径下面的内容；</li>
<li>使用^跳转到父路径</li>
<li>多试几次重复打开和跳转到父路径</li>
<li>C-x b和TAB将会看到通过文件导航打开的一系列路径；每当使用Dired或其他方法打开一个文件或路径，你将得到一个那个路径的缓冲区 </li>
</ul>
<p>或许Dired打开了太多的缓冲区并失控会让你讨厌，不用担心，这就是你为什么使用ibuffer</p><ul>
<li>M-x ibuffer或如果你已经替换掉list-buffers使用C-x C-b。</li>
<li>/ m 选择dired-mode。/ g并命名Dired组将得到一个单独拥有路径管理的组，不再有其他缓冲区的混乱试图，现在不用担心了。 <center> <div class="image">
<img src="ibuffer-dired-group.gif" alt="ibuffer-dired-group.gif"/>
</div>
 </center> </li>
</ul>
<p>如果你想进入访问的路径，打开ibuffer查找，这对复杂路径非常有效。例如，你需要在下面的个路径下不停地工作：</p><ul>
<li>directory_root/dir1/dir2/dir3/dir4/</li>
<li>directory_root/dir2/dir2/dir3/dir4/</li>
<li>directory_root/dir5/dir6/dir7/dir8/</li>
<li>…. </li>
</ul>
<p>当想创建补丁时前两个路径的布局相同。在像windows浏览器这样的通常的文件管理下工作时，你只有一个路径视图。来回跳转乏味低效，你还需要记住不同的路径。为简单起见你需要手工打开多个文件浏览器。终端下，为了节省时间你需要为那些路径创建符号链接，但是你仍需手动管理链接，比如不再使用时进行删除或链接指向的路径被删除时进行更新。这些工作Emacs都自动为你做了，利用这一特征，你可以自由的导航文件系统而无需记住工作路径以备以后跳转回来，因为你可以方便快捷的跳转回来</p>
<h3><a class="anchor" id="fsdfilemarr"></a>
文件标记</h3>
<p>标记文件进行删除，或为了其他（诸如拷贝，移动，链接等等）操作进行标记。特殊的文件类型有许多标记命令，除了m,% m和% g外，所有的标记命令都有前缀*。我将列举最有用的一个，你可以在Dired手册中查找其他的标记命令。 </p><pre class="fragment">m   标记光标处的入口，使用前缀参数向上或下可以标注多个入口
% m 标记所有满足正则表达式的文件
% g 匹配所有文件内容匹配提供的正则表达式的文件，与Grep相同
</pre><p> 练习列表中的命令，为下一部分保留几个文件/路径的标记。 </p>
<h3><a class="anchor" id="fsdfwopjfing"></a>
文件操作</h3>
<p>这些命令使用大写字母，如看到使用大写字母的命令，表示 S-&lt;character&gt; </p><pre class="fragment">C   提示一个路径用于拷贝标记的文件或光标处的文件（如果没有文件被标记）
R   提示一个路径用于移动或重命名标记的文件或光标处的文件（如果没有文件被标记），与shell中的mv命令相同
H   提示一个路径用于创建硬链接
S   提示一个路径用于创建符号链接
M   修改标记文件或光标处的文件（如果没有文件被标记）的许可位。
</pre><p> 练习：</p><ul>
<li>在当前路径下创建一个文件夹</li>
<li>假设你还保留有之前练习中创建的标记；C并提示你已经创建的路径，回车确认。</li>
<li>如果你想移动标记的文件或路径使用R，如果你想更名，标记单个文件/文件夹并在提示区输入一个新名称。</li>
<li>输入你刚拷贝文件的路径</li>
<li>将光标移动到一个文件，输入H创建硬链接。会有提示要求输入目标路径和链接名，在当前位置使用与原始名称不同的名字创建一个链接。</li>
<li>将光标移动到一个文件，输入S创建符号链接。会有提示要求输入目标路径和链接名，在当前位置使用与原始名称不同的名字创建一个链接。</li>
<li>将光标移动到刚创建的硬链接或符号链接上，用M改变许可位；设置成如000这样的值</li>
<li>之后，按下g刷新Dired缓冲区。查看链接指向的原始文件，你会看到许可属性被清除，你不能访问那些文件 </li>
</ul>
<h3><a class="anchor" id="dejkwewdeui"></a>
删除文件</h3>
<pre class="fragment">d   标记文件用于删除
u   移除有删除标记的文件
#   标记所有自动保存的文件（文件名以#开头和结尾的文件）
~   标记所有备份文件
% &amp;*    标记删除所有匹配 dired-garbage-files-regexp的文件
% d 标记匹配正则表达式的文件
x   确认删除标记的文件
</pre> <h3><a class="anchor" id="exfjhfusexc"></a>
在Dired中执行shell命令</h3>
<p>像在shell中一样，也可以在Dired中在当前路径下执行命令。 </p><pre class="fragment">!   在选中的文件或文件组上执行一个命令。
&amp;   在选中的文件或文件组上异步执行一个命令。
</pre> <h3><a class="anchor" id="sbfcicdncsq"></a>
文件比较</h3>
<pre class="fragment">=   比较光标处的文件与迷你缓冲区中输入的文件；
</pre> <h3><a class="anchor" id="fjsfjsksubgs"></a>
子路径</h3>
<p>这是Dired的一个令人兴奋的特征，在其他的文件浏览器中，你的到一个树用于浏览你的路径。如果你有一个很深的路径结构，这很快就会变成一件令人讨厌的事。Dired允许用户在当前路径下插入路径的内容，可以在两个路径下使用C-s搜索文件名，可以插入任意数量的子目录。移动光标到Dired中的一个路径上，按下i，将会看到另一个路径插入到了下面：</p>
<center> <div class="image">
<img src="dired-subdir.gif" alt="dired-subdir.gif"/>
</div>
 </center> <p>在一个项目中多个相关路径下工作时，这非常的有效率。</p>
<p>练习：</p><ul>
<li>打开一个有子文件夹的路径</li>
<li>使用i插入子路径</li>
<li>还记得书签吗？可以使用书签保存Dired缓冲区以备后面使用。C-x r m并保存当前有子路径的Dired缓冲区。</li>
<li>销毁当前有子路径的Dired缓冲区</li>
<li>通过书签列表C-x r l打开Dired缓冲区，你会发现不但完整恢复了Dired缓冲区，子路径也恢复了 </li>
</ul>
<h2><a class="anchor" id="refaggjadregist"></a>
寄存器</h2>
<p>当第一次听到Emacs中的寄存器时，我被吓到了，我想“哇，寄存器是什么东东？ 我要直接使用CPU寄存器吗？”，事实证明，处理叫做寄存器外，实际上并没有那么难以理解。尽管如此，Emacs寄存器与CPU寄存器类似，它允许快速访问临时数据。每一个Emacs寄存器有一个单字符名字，我们将用r标识，r可以说一个字母（如‘a’）或数字（如‘1’），大小写敏感，如寄存器‘a’不同于寄存器‘A’。</p>
<p>Emacs中寄存器用于快速获取对象。对象包括一个位置、一段文本、一个矩形，一个数字，一个文件名或者windows配置（是的，你可以保存Emacs样式，并在以后恢复）。保存不同的类型，有不同的键绑定，但是跳转到一个寄存器，有一个单一的命令C-x r j REG，REG是你选择的寄存器。寄存器命令的前缀键是C-x r，如果忘了键绑定，使用C-x r C-h获得键绑定列表。</p>
<h3><a class="anchor" id="fsdkfabfksasea"></a>
保存Window配置</h3>
<p>这是寄存器一个最棒的应用，可以保存当前的window配置，并在以后恢复样式。例如，你在查看4个代码缓冲区，这时你想并列打开两个Dired缓冲区管理文件，因此你关闭了两个window并切换另两个到Dired缓冲区。但这会使你失去完美的样式，之后你需要繁琐的逐个恢复这些window到原始的样式。然后你还要做一些其他的工作，中断窗口配置，再次手动恢复window配置，还需要准确记住你使用的缓冲区。想减轻这个负担，寄存器就是答案。你可以保存四个显示缓冲区的window配置，还可以保存项目中有两个Dired缓冲区的配置。可以简单的在它们之间切换。 </p><pre class="fragment">C-x r w REG 命令: window-configuration-to-register 保存当前frame的window配置到REG寄存器；
C-x r f REG 命令: frame-configuration-to-register 保存所有frame的状态包括他们所有的window到REG寄存器
C-x r j REG 命令: jump-to-register 跳转到寄存器REG
</pre> <p>REG可以是一个字母（如‘a’）或数字（如‘1’），大小写敏感，如寄存器‘a’不同于寄存器‘A’。示例：例子中使用C-x r w将两个windows配置保存到寄存器a和寄存器b。寄存器a存储包含两个项目路径的Dired缓冲区，然后，我在这两个路径下打开两个文件，创建另一个类似的窗口并打开另一个文件。突然，我想回到我的项目根，当我执行C-x r j时我得到一个输入提示，输入a后Emacs切换回Dired缓冲区。之后我输入C-x r j并在提示区输入b后我切换回正在编辑的文件处。当你在底部看到提示“Eval：START”时示例开始。</p>
<center> <div class="image">
<img src="register-windows.gif" alt="register-windows.gif"/>
</div>
 </center><p> 练习：</p><ul>
<li>保存几个窗口配置到寄存器中，建议每一个窗口配置应该代表项目中的一个工作区。但也可以是你任何喜欢的，取决于你的想象。</li>
<li>通过跳转到合适的寄存器，在Window配置间跳动 </li>
</ul>
<h3><a class="anchor" id="asdfaevesdfjsave"></a>
保存frame配置</h3>
<pre class="fragment">C-x r f REG 保存当前的frame配置到寄存器REG中
</pre> <p>如果使用frame命令（前缀为C-x 5）创建多个frame，你可能想保存里面有不同的window配置的frame以备后用。例如，我有一个frame用于读文档，主frame用于编写和浏览代码，完成工作后，我关闭额外的frame保持主frame激活。之后，当我需要那个额外窗口的时候，我可以使用寄存器中的frame集合恢复。</p>
<p>练习：</p>
<ul>
<li>使用C-x 5 2， C-x 5 d， C-x 5 f等创建一个新frame集合</li>
<li>将fram集合保存到寄存器中</li>
<li>关闭主frame外的其他frame</li>
<li>通过跳转到保存frame集的寄存器恢复frame集合 </li>
</ul>
<h3><a class="anchor" id="safdfjdsvet"></a>
保存文本</h3>
<p>可以在寄存器中保存一个区域： </p><pre class="fragment">C-x r s REG 命令: copy-to-register 拷贝区域到寄存器REG
C-x r i REG 命令: insert-register 从寄存器REG插入文本
</pre> <p>REG可以是一个字母（如‘a’）或数字（如‘1’），大小写敏感，如寄存器‘a’不同于寄存器‘A’。你可能疑惑，将文本放到寄存器中有什么用？还记得清除环吗？原因如下：</p><ul>
<li>你已经知道，从清除环中插入内容会选择头入口处的内容。这非常不方便，这时候使用寄存器存储多片文本而不影响清除环就非常方便了。例如，你阅读一个手册（man页或info页），你想记住一些关键字，并在其他地方插入，这种情况下寄存器可以帮助你。</li>
<li>你还可以使用寄存器保存许多代码模板。例如，你可以保存for循环模板到寄存器f，if模板到寄存器i，函数定义到寄存器F，等等。在你学习一个新语言并时不时忘记语法的时候就非常有用了。例如，如果你是一个新手，那么下面的C++11代码段将很难记住： <pre class="fragment">  auto it = find_if (vertices.begin(), vertices.end(), [&amp;v_idx] (const Vertex&amp; o) -&gt; bool {
    return o.id == v_idx;
});
</pre> </li>
</ul>
<p>我把这段代码保存到了寄存器中，根据我的需求插入和修改，直至我能记住这个函数的用法，这比回到之前的代码位置查找更高效，尤其是在代码庞大的时候。练习：</p><ul>
<li>拷贝一段代码到寄存器中</li>
<li>在一个缓冲区重新插入这段代码 </li>
</ul>
<h3><a class="anchor" id="fjsajksavrec"></a>
保存矩形</h3>
<pre class="fragment">C-x r r REG 命令: copy-rectangle-to-register 拷贝region-rectangle到寄存器REG， 使用C-u前缀也可以删除
C-x r i REG 插入寄存器REG中的rectangle。
</pre> <p>练习：</p><ul>
<li>保存rectangle到寄存器中以习惯其用法。</li>
<li>将寄存器中的rectangle插入到缓冲区中。 </li>
</ul>
<h3><a class="anchor" id="jsdhfjkaskjf"></a>
保存位置</h3>
<pre class="fragment">C-x r &lt;SPC&gt; REG 命令: point-to-register 将光标位置和当前缓冲区保存到寄存器REG中
C-x r j REG 命令: jump-to-register 跳转到保存在寄存器REG中的缓冲区和位置处，如果缓冲区已经清除，重新访问文件打开缓冲区后跳转。
</pre> <p>当与宏（后面会讲）一起使用时，保存位置非常有用。<b>重要提示：</b>当跳转到寄存器中的一个位置的时候，Emacs总是跳转到那个位置，即使缓冲区中的内容已经改变。也就是说，如果你已经将一个位置保存到寄存器中，当位置所在的缓冲区内容发生改变时，保存的位置也会改变。比方说，你保存了位置100（第100个字符的位置），你在第100个字符的前面添加或删除了一些字符，保存在寄存器中的位置也会随着添加或删除的数字进行改变。练习：</p>
<ul>
<li>使用C-x r SPC a保存一个位置到寄存器a</li>
<li>将光标移动到其他地方</li>
<li>通过C-x r j a跳转回之前的位置</li>
<li>将光标向后移动几个字符</li>
<li>添加几个字符</li>
<li>使用C-x r j a跳转到寄存器中的位置</li>
<li>你会发现光标不会跳转到原来的位置，而是离原来位置数等于新加字符数的位置。</li>
<li>回到首行回车增加一行</li>
<li>使用C-x r j a跳转到寄存器中的位置</li>
<li>你会发现新的位置也增加了一行 </li>
</ul>
<h3><a class="anchor" id="sfnsakfsgsdf"></a>
保存数字</h3>
<pre class="fragment">C-u number C-x r n REG  命令: number-to-register 将number保存到寄存器REG中
C-u number C-x r + REG  命令: increment-register 如果REG中有一个数字，在寄存器中将这个数字增加number
C-x r i REG 插入寄存器REG中的数字。
</pre> <p>当使用键盘宏的时候这些数字非常便利。练习：</p>
<ul>
<li>保存一些数字到寄存器</li>
<li>将保存到寄存器中的数字任意增加一个数字</li>
<li>将寄存器中的数字插回到缓冲区，观察变化结果 </li>
</ul>
<h2><a class="anchor" id="fdsasfasdfjcx"></a>
宏</h2>
<p>宏将你在Emacs中的操作记录下来，供后续回放 </p><pre class="fragment">f3 或者 C-x ( 开始录制宏
f4 或者 C-x ) 停止录制宏
C-x e 或者 f4 回放宏
</pre> <p>我习惯使用f3和f4录制和回放，因此我不需要按下更多的键。想多次重复一个宏，使用前缀，例如 C-u 10 &lt;f4&gt;执行一个宏10次，如果你要取消录制，使用C-g。</p>
<p>练习1：将下面这些行拷贝到一个缓冲区中： </p><pre class="fragment">aaaaabbbbbbbccccccdddddd
aaaaabbbbbbbccccccdddddd
aaaaabbbbbbbccccccdddddd
aaaaabbbbbbbccccccdddddd
aaaaabbbbbbbccccccdddddd
aaaaabbbbbbbccccccdddddd
aaaaabbbbbbbccccccdddddd
aaaaabbbbbbbccccccdddddd
aaaaabbbbbbbccccccdddddd
aaaaabbbbbbbccccccdddddd
aaaaabbbbbbbccccccdddddd
aaaaabbbbbbbccccccdddddd
aaaaabbbbbbbccccccdddddd
aaaaabbbbbbbccccccdddddd
</pre><p> 现在你要把每行划分到不同的组，每组包含自己的字符，像下面这样： </p><pre class="fragment">aaaaa bbbbbbb cccccc dddddd
</pre><p> 在很多编辑器中，你不得不手动完成。在Emacs中你不需要自己重复，尝试下面的步骤：</p><ul>
<li>将光标放置在第一行开始处</li>
<li>按下f3</li>
<li>使用C-s search-and-jump搜索跳转到每个字符组的开头（或者C-f你想简单一点）并添加一个空格</li>
<li>跳转到下一行的开始处按下 &lt;f4&gt; 结束录制</li>
<li>按下f4观察Emacs回放刚录制的整个动作序列</li>
<li>如果你想回放多次，使用前缀参数。如果你想重复执行到文件末尾使用前缀参数0：C-u 0 &lt;f4&gt;或者高亮剩下的行，执行C-x C-k r：在区域中每行的开头运行最后一次的键盘宏 (apply-macro-to-region-lines)。 <center> <div class="image">
<img src="macro.gif" alt="macro.gif"/>
</div>
 </center> </li>
</ul>
<p>宏被定义后，保存在键盘宏环，仅有一个键盘宏环被所有的缓冲区共享。所有操作键盘宏环的命令使用C-x C-k前缀，只要记住C-x C-k等于宏命令，你就会发现宏键盘绑定并不难记。 </p>
<p>练习2：将数据从一种格式转换成另一种，假设我有下面的数据表： </p><pre class="fragment">machine1=(aa:bb:cc:dd:ee:a1 aa:bb:cc:dd:ee:a2 aa:bb:cc:dd:ee:a3)
machine2=(aa:bb:cc:dd:ee:b1 aa:bb:cc:dd:ee:b2 aa:bb:cc:dd:ee:b3)
machine3=(aa:bb:cc:dd:ee:c1 aa:bb:cc:dd:ee:c2 aa:bb:cc:dd:ee:c3)
machine4=(aa:bb:cc:dd:ee:d1 aa:bb:cc:dd:ee:d2 aa:bb:cc:dd:ee:d3)
machine5=(aa:bb:cc:dd:ee:e1 aa:bb:cc:dd:ee:e2 aa:bb:cc:dd:ee:e3)
machine6=(aa:bb:cc:dd:ee:f1 aa:bb:cc:dd:ee:f2 aa:bb:cc:dd:ee:f3)
</pre><p> 基本上每一行包含我工作的地方的服务器集群中一台设备的MAC地址，这些数据保存在一个文本文件中，现在我们需要将这些数据集成到YAML文件中做些什么，我需要将上面的数据格式转换成下面的形式： </p><pre class="fragment">machine 1:
    mac1: aa:bb:cc:dd:ee:a1
    mac2: aa:bb:cc:dd:ee:a2
    mac3: aa:bb:cc:dd:ee:a3
</pre> <p>真实的文件中大约包含50个入口，手工进行转换将非常令人厌烦，幸亏有了Emacs，我用一个键盘宏搞定了这个问题。 </p>
<p>前期准备：录制宏自动实现这个转换之前，我们需要进行一些设置：</p><ul>
<li>使用C-x b创建两个相邻的缓冲区，命名左侧的缓冲区为buf1，右侧的为buf2。</li>
<li>把数据粘贴到buf1，并将光标移动到缓冲区开始处 看起来这样： <center> <div class="image">
<img src="prepare_macro.gif" alt="prepare_macro.gif"/>
</div>
 </center> 录制:光标应该在buf1，数据第一行的开头</li>
<li>按下f3开始</li>
<li>C-SPC后M-f，这将标记单词machine1.使用C-x r s a将这个词保存在寄存器a中 <center> <div class="image">
<img src="reg_a.gif" alt="reg_a.gif"/>
</div>
 </center></li>
<li>移动光标到第一个MAC地址开始处。C-SPC后C-s搜索第一个分隔符（空格），C-b退回到第一个MAC地址结尾，将这部分用C-x r s b保存到寄存器b中； <center> <div class="image">
<img src="reg_b.gif" alt="reg_b.gif"/>
</div>
 </center></li>
<li>接下来，将光标移动到第二个MAC地址的开头，C-s空格，C-b回退一个字符，使用C-x r s c将这部分保存在寄存器c中 <center> <div class="image">
<img src="reg_c.gif" alt="reg_c.gif"/>
</div>
 </center></li>
<li>同样做法，将最后一个MAC地址保存到寄存器d中 <center> <div class="image">
<img src="reg_d.gif" alt="reg_d.gif"/>
</div>
 </center></li>
<li>C-x o切换到第二个缓冲区，按照模板，将寄存器a到d插入到缓冲区中 <center> <div class="image">
<img src="insert_buf2_macro.gif" alt="insert_buf2_macro.gif"/>
</div>
 </center></li>
<li>插入完成后，将光标移动到下一个空行</li>
<li>使用C-x o切换回缓冲区buf1</li>
<li>移动到下一行的开始</li>
<li>按下f4停止录制 </li>
</ul>
<p>回放：现在可以回放新建的键盘宏来实现剩余部分的转换，这是完整的过程： </p><center> <div class="image">
<img src="macro2_full.gif" alt="macro2_full.gif"/>
</div>
 </center> <h3><a class="anchor" id="jfisjkbaijif"></a>
键盘宏环</h3>
<pre class="fragment">C-x C-k C-k 命令: kmacro-end-or-call-macro-repeat 执行键盘宏环头部的键盘宏
C-x C-k C-n 命令: kmacro-cycle-ring-next 切换键盘宏环到下一个宏（之前的定义）
C-x C-k C-p 命令: kmacro-cycle-ring-previous 切换键盘宏环到上一个宏（后面的定义）
</pre> <p>练习：定义几个键盘宏，练习上面的命令。 </p>
<h3><a class="anchor" id="jfkasjdfkoa"></a>
键盘宏计数</h3>
<p>每一个宏有一个计数，初始化为0，每次一个计数插入缓冲区的时候他的值增加1. </p><pre class="fragment">\&lt;f3\&gt;  命令: kmacro-start-macro-or-insert-counter 将计数插入缓冲区并将计数增长1，只在宏录制时有效
C-x C-k C-i 命令: kmacro-insert-counter 将当前宏计数插入到缓冲区
C-x C-k C-c 命令: kmacro-set-counter 修改当前宏的计数值
C-x C-k C-a 命令: kmacro-add-counter 将一个数字增加到当前的键盘宏计数，如在运行该命令前使用C-u前缀，则将键盘宏计数重置到之前的值
C-x C-k C-f 命令: kmacro-set-format 指定插入键盘宏计数的样式
</pre> <p>用于C-x C-k C-f的有效样式：</p><ul>
<li>o 插入8进制整数形式</li>
<li>d 插入十进制整数形式</li>
<li>x 插入十六进制整数形式，使用小写字母</li>
<li>X 插入十六进制整数形式，使用大写字母</li>
<li>c 插入给定数字的字符</li>
<li>e 为浮点数插入指数表示法</li>
<li>f 为浮点数插入小数点表示法</li>
<li>g 插入浮点数表示法，使用指数表示法或小数表示法中较短的一个</li>
<li>%% 插入一个‘’，由于不使用数值，这种格式不常见，例如格式 “%% d” 30返回 %30 样式必须包含上面至少一种或与其他文本组合，例如这些是合法的样式： The format must contain at least one of the valid specification above or combination with other text. For example, these are valid format:</li>
<li>0xx</li>
<li>Project d:</li>
<li>Plain text </li>
</ul>
<p>练习1：创建增量头前缀 </p>
<p>格式规范有助于用宏进行格式化输出，与计数器结合使用，有助于在行首添加带编号的前缀。例如：我们通常编写代码注释描述步骤序列： </p><pre class="fragment">- Step 1 of 5: ...
- Step 2 of 5: ...
- Step 3 of 5: ...
- Step 4 of 5: ...
- Step 5 of 5: ...
</pre> <p>键盘宏可以毫不费力的帮你生成这样的文本样式。</p><ul>
<li>C-x C-k C-f 输入这个样式: - Step d of 5:</li>
<li>&lt;f3&gt; 开始录制</li>
<li>再次按下&lt;f3&gt;插入第一个计数值 - Step 0 of 5:</li>
<li>回车到下一行</li>
<li>&lt;f4&gt;停止录制宏</li>
<li>多次按下 &lt;f4&gt; 观察前缀插入的同时数值的增长。</li>
<li>你可以简单的通过C-x C-k C-c插入任意值的文本；</li>
<li>记得下次你写描述算法步骤的代码注释时使用这个方法。 </li>
</ul>
<p>练习2：生成一个数字数组 </p>
<p>使用宏计数，可以轻松的在支持的基数中生成数字列表：</p><ul>
<li>C-x C-k C-f 和一个像d的样式（也可以是你喜欢的样式）。</li>
<li>初始化宏计数为一个你喜欢的数字</li>
<li>f3开始录制</li>
<li>如果你想数字之间相差5个单位（或其他大于1的值），使用C-x C-k C-a为计数增加一个数值，如果你只想增加1，跳过这步，因为默认的步长是1.</li>
<li>f3插入首个数字</li>
<li>SPC输入分隔符</li>
<li>f4停止录制</li>
<li>重复f4观察数字生成 </li>
</ul>
<h3><a class="anchor" id="fsafjsfafsf"></a>
可变宏(55555这个命令好像不可用)</h3>
<p>对于重复编辑工作来说，宏相当的好用。然而，有时候你有一个可以使用宏的可重复任务，但这个任务不是一直可重复：任务的一部分会在每次重复的时候发生改变。例如：有一个文本模板，里面有一些空白字段用于填入合适的信息。键盘宏支持这种用例。定义键盘宏的时候，使用C-x q标记过程中的当前点，当键盘宏执行并到达这一点时，将会要求确认：</p><ul>
<li>Y：正常完成此迭代，然后继续下一个；</li>
<li>N：跳过此迭代的其余部分，然后开始下一个。</li>
<li>RET 立即完全停止宏。</li>
<li>C-l重新显示屏幕，然后再次询问。</li>
<li>C-r从点开始编辑。 C-M-c返回宏执行 </li>
</ul>
<p>练习：插入交互模板，假设你在练习Agile，需要写许多下面的用户故事： </p><pre class="fragment">As a \&lt;type of user\&gt;, I want \&lt;some goal\&gt; so that \&lt;some reason\&gt;.
</pre> <p>显然，您不想重复模板文本，例如“作为”，“我想要”或“如此”。 唯一变化的内容是"type of user","some goal"和"some reason"。你可以在这些检查点创建一个宏停止并等待你的操作。C-r开始编辑。</p><ul>
<li>首先，拷贝这个模板： <pre class="fragment">As a , I want , so that
</pre></li>
<li>f3开始录制</li>
<li>C-y插入模板</li>
<li>移动光标到需要修改的地方，按下C-x q。</li>
<li>f4停止录制。</li>
<li>现在按下f4，你会看到宏停在了你之前按下C-x q的地方，并提示你进行操作。</li>
<li>C-r编辑，完成后使用C-M-c回去。</li>
<li>你可以像问前面一样的问题，如果你还忘了什么，C-r继续编辑。否则，按下y处理下一个点。</li>
<li>重复直至宏结尾。 </li>
</ul>
<h3><a class="anchor" id="fnannaisdad"></a>
命名和保存宏</h3>
<ul>
<li>C-x C-k n 命令: kmacro-name-last-macr 为最近定义的键盘宏指定命令名称（在Emacs会话持续时间内）</li>
<li>C-x C-k b 命令: kmacro-bind-to-key 绑定最近定义的键盘宏到一个键序列（在Emacs会话持续时间内） </li>
</ul>
<p>宏有名字以后就变成了一个名字，可以使用M-x找到也可以使用M-x insert-kbd-macro保存。执行这个命令时，会提示你输入一个宏名称（可以使用TAB补全名称）；选择一个宏，然后将所选宏的Lisp代码插入到当前缓冲区中，然后保存该缓冲区。 您应该为自己的键盘宏设置一个专用文件。 您可以使用命令load-file重新加载此文件以供以后的Emacs会话使用。</p>
<p>还可以将宏绑定到任何键序列。 但是，为避免与现有的键绑定冲突，应使用前缀C-x C-k。 例如，您可以将宏绑定到C-x C-k 1，另一个绑定到C-x C-k 2…</p>
<p>练习1：将你的宏保存到一个文件</p><ul>
<li>录制一些键盘宏</li>
<li>使用C-x C-k n给这个宏命名</li>
<li>使用C-x C-k b将这些宏绑定到C-x C-k 1，C-x C-k 2等。</li>
<li>创建文件 ~/.emacs.d/init.el，如果没有这个路径和文件，使用find-file创建。</li>
<li>使用find-file创建文件~/.emacs.d/macros，创建完成后将将光标切换到这个文件；</li>
<li>使用M-x insert-kbd-macro保存宏；</li>
<li>为避免手动载入这个宏文件，将下面的代码放到~/.emacs.d/init.el: <pre class="fragment">(load-file "~/.emacs.d/macros")
</pre></li>
<li>上面的代码实际上加载指定路径的文件，只对Lisp源码文件有效。</li>
<li>现在，每次Emacs启动，将会自动加载宏文件。默认情况下，Emacs加载~/.emacs.d/init.el中的所有的Emacs Lisp代码。因为你把上面的代码加入到了init.el中，你的宏文件也会被加载。 </li>
</ul>
<p>练习2：复合宏 </p>
<p>回到在“宏”部分开头的练习2，您还记得必须创建一个大宏来转换文本结构吗？ 当然，可以将其拆分为较小的宏，将这些宏保存到Emacs命令中，然后将它们全部放到一个宏中，这样也可以更轻松地完成。</p><ul>
<li>录制前准备：录制宏实现这个变换之前，我们需要正确的设置： &ndash; 使用C-x b创建两个相邻的缓冲区，命名左边的缓冲区为buf1，右边的为buf2。 &ndash; 将原始数据拷贝到缓冲区buf1，并将光标移动到缓冲区开始处： <pre class="fragment">machine1=(aa:bb:cc:dd:ee:a1 aa:bb:cc:dd:ee:a2 aa:bb:cc:dd:ee:a3)
machine2=(aa:bb:cc:dd:ee:b1 aa:bb:cc:dd:ee:b2 aa:bb:cc:dd:ee:b3)
machine3=(aa:bb:cc:dd:ee:c1 aa:bb:cc:dd:ee:c2 aa:bb:cc:dd:ee:c3)
machine4=(aa:bb:cc:dd:ee:d1 aa:bb:cc:dd:ee:d2 aa:bb:cc:dd:ee:d3)
machine5=(aa:bb:cc:dd:ee:e1 aa:bb:cc:dd:ee:e2 aa:bb:cc:dd:ee:e3)
machine6=(aa:bb:cc:dd:ee:f1 aa:bb:cc:dd:ee:f2 aa:bb:cc:dd:ee:f3)
</pre> 就是这些，现在看起来像这样： <center> <div class="image">
<img src="prepare_macro.gif" alt="prepare_macro.gif"/>
</div>
 </center></li>
<li>录制： </li>
</ul>
<p>光标应该在buf1，数据第一行的开头。我们创建第一个宏命令，用save-macs命令保存每一个入口点的信息到寄存器a,b,c,d: </p><ol>
<li>
f3 开始录制宏  </li>
<li>
C-SPC后M-f，标记单词machine1.使用C-x r s a将这个词保存在寄存器a中  <center> <div class="image">
<img src="reg_a.gif" alt="reg_a.gif"/>
</div>
 </center> </li>
<li>
将光标移动到第一个MAC地址前面。C-SPC后C-s搜索第一个分隔符（空格）。C-b回到第一个MAC地址的结尾处，将这个区域通过C-x r s b保存到寄存器b中。  <center> <div class="image">
<img src="reg_b.gif" alt="reg_b.gif"/>
</div>
 </center> </li>
<li>
将光标移动到第二个mac地址的开头，C-s 空格 C-b回退一个字符。使用C-x r s c将这部分保存在寄存器c中。  <center> <div class="image">
<img src="reg_c.gif" alt="reg_c.gif"/>
</div>
 </center> </li>
<li>
重复操作将最后一个MAC地址保存到寄存器d中  <center> <div class="image">
<img src="reg_d.gif" alt="reg_d.gif"/>
</div>
 </center> </li>
<li>
将光标移动到下一行的开头；  </li>
<li>
f4停止录制，C-x C-k n使用名字save-macs保存宏：  </li>
</ol>
<ul>
<li>接下来我们创建第二个宏命令，insert-macs： <ol>
<li>
使用C-x o切换到第二个缓冲区；  </li>
<li>
f3开始录制  </li>
<li>
按照模板插入寄存器a到d：  <center> <div class="image">
<img src="insert_buf2_macro.gif" alt="insert_buf2_macro.gif"/>
</div>
 </center> </li>
<li>
插入完成后，将光标移动到下一个空行。  </li>
<li>
<p class="startli">f4停止录制，C-x C-k n使用名字insert-macs保存宏。  </p>
<p class="endli">现在我们有了两个重要的宏，我们把它们一起放回来： </p>
</li>
<li>
使用C-x o切换到buf1，将光标移动到第二个入口处  </li>
<li>
f3开始录制  </li>
<li>
M-x save-macs，执行完成后光标移动到第二行。  </li>
<li>
C-x o跳转到缓冲区buf2.光标在第一次插入的machine1后面  </li>
<li>
M-x insert-macros；这个命令后数据插入到缓冲区中  </li>
<li>
C-x o切换回buf1  </li>
<li>
按下f4停止录制  </li>
</ol>
</li>
</ul>
<p>回放：回放新的键盘宏完成剩余的转换。</p>
<h3><a class="anchor" id="dklskdsfs"></a>
编辑键盘宏</h3>
<ul>
<li>C-x C-k C-e 命令: kmacro-edit-macro 编辑最后定义的键盘宏</li>
<li>C-x C-k e name &lt;RET&gt; 命令: edit-kbd-macro 编辑一个之前定义的键盘宏名</li>
<li>C-x C-k l 命令: kmacro-edit-lossage 将最近的300次键盘操作当做键盘宏 </li>
</ul>
<p>当你运行一个不正确的命令时编辑键盘宏很有用，不用完整的做一遍，只需要编辑不正确的部分。请注意，请勿按C-g键，否则您将杀死当前的录制宏。 按f4代替完成宏，然后对其进行编辑。 完成编辑后，从上一个中断的地方继续：</p><ul>
<li>C-u &lt;f3&gt;: 重新执行最后一个键盘宏，然后将键附加到其定义。</li>
<li>C-u C-u &lt;f3&gt;: 将键附加到最后一个键盘宏，而不重新执行它。 </li>
</ul>
<h3><a class="anchor" id="sfjasdpdinnffa"></a>
交互式键盘宏编辑</h3>
<p><b>C-x C-k SPC</b>运行kmacro-step-edit-macro 这样您就可以像调试器一样一次一次查看最后一个键盘宏的命令。 进入此模式时，您有一组预定义的命令可应用于每个命令。 按 ？ 获取可用交互命令的列表并进行操作。 </p>
<h3><a class="anchor" id="jajfsjf"></a>
高效使用宏的提示</h3>
<ul>
<li>查找模式：在完成所有练习之后，您可以看到成功的宏是满足特定条件时可重复的宏。基本上，对于文本转换，您需要创建一个具有适当初始化和结束条件的循环。如果数据没有模式，请尝试以可重复的方式组织它。如您在练习中所见，数据的布局方式使宏可以自然地重复：每一行都是一个迭代。</li>
<li>您还可以对几乎所有与Emacs中的文本无关的内容使用宏。 例如，您可以创建一个宏来运行查找文件并转到~/Downloads。</li>
<li>使用寄存器：如您在练习中所见，宏是一种存储信息的好方法。 您可以将寄存器用作临时信息持有人，并在以后将这些信息组织为任意结构。</li>
<li>慢慢做，然后再思考：不要着急。 足够缓慢地执行此操作，以确保当您按某些键并执行某些命令时，它是正确的。</li>
<li>将大宏分解为较小的宏 </li>
</ul>
<h2><a class="anchor" id="fsfvbaokmv"></a>
版本控制</h2>
<p>这部分直接来自GNU Emaca教程，略作修改。Emacs帮助你管理和编辑版本控制中的文件。Emacs支持CVS、Subversion，bzr，git，hg等。但是，不管你使用什么版本控制工具，它提供了一个统一的接口称作VC。这样做的好处是，即使你不熟悉一些版本控制系统（VCS），你仍然可以快速的使用这些VCS工作，而无需费心学习特定的VCS。</p>
<p>当你编辑的文件在版本控制之下，Emacs会自动的进行检测，并在状态行显示诸如：CVS-1.14等来标识正在使用的版本控制系统及其当前版本。M-x vc-next-action或 C-x v v提交当前你编辑过的文件（提示你输入日志信息）， 在需要锁定的版本控制系统下，此命令还会为您获取锁定。VC提供了其他版本控制相关的命令：</p><ul>
<li>C-x v = 命令: vc-diff 显示当前文件的变化</li>
<li>C-x v ~ Commmand: vc-revision-other-window 提示您输入版本号，并在另一个窗口中显示当前文件的版本。</li>
<li>C-x v g 命令: vc-annotate 显示文件的带注释的版本，每行显示该行的最后更改位置和提交者的提交。 在任何行上，您可以按l查看该提交的日志消息，或按d查看关联的差异。</li>
<li>C-x v l 命令: vc-print-log 显示文件先前更改的日志。 当光标位于特定日志条目上时，可以按d查看与该更改关联的差异，或按f查看该文件的版本。</li>
<li>C-x v u 命令: vc-revert 将所选文件集的工作副本恢复为其存储库内容，这要求确认如果缓冲区版本与工作修订版本不同（关键字扩展除外）。 </li>
</ul>
<p>可以使用C-x v C-h获取更多操作列表。如果使用git，有一个Git专用的包：<a href="https://github.com/magit/magit">Magit</a>，提供了很多比Emacs原生接口更好的特性，一部分特性除外，如:C-x v =, C-x v ~ 和 C-x v u。所有版本控制相关的命令前缀键为C-x v。上面只是我认为最有用和最常用的一小部分，即使我使用Magit时也是这样。 </p>
<p>练习：我们练习一下Emacs这个不错的功能：</p><ul>
<li>首先，随机下载一个Git存储库。</li>
<li>打开存储库中的任何文件。</li>
<li>编辑该文件并保存。 在不同的地方做，我们会有很多变更。</li>
<li>C-x v =精确了解您所做的更改。</li>
<li>C-x v g查看谁在什么提交上更改了哪一行。</li>
<li>C-x v ~选择一个提交。 选择后，该修订版的版本将显示在另一个缓冲区中。</li>
<li>测试完毕后，使用C-x v u将缓冲区恢复为原始状态。</li>
<li>回滚并重复直到它成为您工作流程的一部分。 </li>
</ul>
<h2><a class="anchor" id="sfsggfsklas"></a>
shell</h2>
<p>Emacs中有三种类型的shell命令：shell，term和eshell，这里我仅引用一下 Stackexchange中一篇不错的回答： </p><pre class="fragment">shell is the oldest of these 3 choices. It uses Emacs's comint-mode to run a subshell (e.g. bash). In this mode, you're using Emacs to edit a command line. The subprocess doesn't see any input until you press Enter. Emacs is acting like a dumb terminal. It does support color codes, but not things like moving the cursor around, so you can't run curses-based applications.

term is a terminal emulator written in Emacs Lisp. In this mode, the keys you press are sent directly to the subprocess; you're using whatever line editing capabilities the shell presents, not Emacs's. It also allows you to run programs that use advanced terminal capabilities like cursor movement (e.g. you could run nano or less inside Emacs).

eshell is a shell implemented directly in Emacs Lisp. You're not running bash or any other shell as a subprocess. As a result, the syntax is not quite the same as bash or sh. It allows things like redirecting the output of a process directly to an Emacs buffer (try echo hello \&gt;\#&lt;buffer results\&gt;).
</pre> <p>这三种shell在Emacs中有什么区别吗？我推荐您使用eshell，因为你可以在Eshell中使用所有的Emacs命令，发送中断信号不用Ctrl+C而是需要使用两次：Ctrl+C Ctrl+C。 </p>
<h1><a class="anchor" id="dkfadknfsjnj"></a>
项目：像专业人士一样浏览Linux内核源代码</h1>
<h2><a class="anchor" id="jfsjksdg"></a>
设定</h2>
<p>你已经学了很多Emacs的知识了，现在你可以使用Emacs做一些实际的工作了，像在庞大的Linux内核代码树中进行跳转。然而，这里仅仅是一个示例，如果您正确学习Emacs，则可以做更多的事情。首先，你需要安装<a href="http://www.gnu.org/software/global/global.html">GNU Global</a>。</p><ul>
<li>Linux:点击<a href="http://www.gnu.org/software/global/download.html">这里</a>下载最新稳定版面的GNU Global。跳转到下载路径，执行如下操作： <ul>
<li>
tar xvf global-&lt;version&gt;.tar.gz  </li>
<li>
cd global-&lt;version&gt;/  </li>
<li>
如果你已经安装了ctag，添加选项&ndash;with-exuberant-ctags并提供安装路径: ./configure [&ndash;with-exuberant-ctags=/usr/local/bin/ctags]  </li>
<li>
make  </li>
<li>
sudo make install  </li>
</ul>
</li>
<li>Windows:</li>
</ul>
<p>Click here and click "DOS and Windows 32 version" to download the binary archive.</p>
<p>After your download the archive, create a directory C:\root and unzip the package into that folder: </p><center> <div class="image">
<img src="gnu-global-dir-struct.jpg" alt="gnu-global-dir-struct.jpg"/>
</div>
 </center><p>Right click on Computer -&gt; Properties -&gt; Advanced System Settings -&gt; Environment Variables.</p>
<p>If PATH variable does not exist, click New. Then in "Variable Name", enter PATH; in "Variable Value", enter C:\root\bin. From now on, if you use ggtags, Emacs knows where to find GNU Global programs. $PATH is the variable where Emacs search for executable programs. If you want more executable programs, add more path to $PATH variable. Each path is separated by ; like this: </p><center> <div class="image">
<img src="path-variable-windows.jpg" alt="path-variable-windows.jpg"/>
</div>
 </center><p>Mac OSX: Mac OSX version is distributed by MacPorts. Then, start Emacs, and press C-x b and switch to <em>scratch</em> buffer. A buffer is an editing area; an editing area may or may not has a file behind it (i.e. A buffer for holding a shell). I will explain more about this later.</p>
<p>Paste the following code into the <em>scratch</em> buffer:</p>
<p>(require 'package) (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t) The above code you see is Emacs Lisp.</p>
<p>Then, M-x eval-buffer and press RET.</p>
<p>After runs eval-buffer, the whole <em>scratch</em> buffer is processed. Then, M-x list-package. Wait a few seconds and you will see of list of plugins for Emacs. In Emacs, a plugin is called a package. Press C-s, and type ggtags and press C-s again. Your cursor will move to the package ggtags. Be sure to select one from melpa; you should see a column written *melpa and select the row that has melpa in it. Press Enter to stay at that position. As you see, C-s is used for searching text inside a buffer.</p>
<p>On the ggtags entry, press i key, which stands for install. Then press x to execute the installation. Emacs will ask you to confirm the installation. Type yes and press Enter. Wait for Emacs to finish its installation.</p>
<p>After installation is done, close the status buffer by pressing C-x 1, switch back to <em>scratch</em> buffer by C-x b. Paste the following code using C-y:</p>
<p>(add-hook 'c-mode-common-hook (lambda () (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode) (ggtags-mode 1)))) You may worry that you have to write Emacs Lisp every time you install something. Don't worry. Most package authors provide code snippets to setup their package properly. All you need to do is copy and paste. The above code is taken from ggtags homepage at configuration section. The configuration is meant to activate ggtags only in a few programming modes.</p>
<p>That's it. Now you can browse kernel easy and fast in Emacs (instant result display).</p>
<p>Browsing the kernel source tree You can enjoy exploring the kernel source tree by following these steps:</p>
<p>Clone the kernel source: git clone <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git</a> ~/linux C-x d and navigate to ~/linux, then press Enter. </p><center> <div class="image">
<img src="linux-dir.gif" alt="linux-dir.gif"/>
</div>
 </center><p>Then, turn on ggtags: M-x ggtags-mode .</p>
<p>Emacs has a file explorer, as you've seen above, called Dired, short for (Dir)ectory (Ed)it. Before start browsing the kernel, you need to create a database for quick searching. Press M-x, type ggtags-create-tags. It asks for a directory; since you're in the root directory of Linux already, press Enter; ggtags asks whether you use ctags (which is another tag generating program, works with more languages but has less features). Type no, press Enter and wait for ggtags to generate the database. </p><center> <div class="image">
<img src="ggtags-create-tags.gif" alt="ggtags-create-tags.gif"/>
</div>
 </center><p>After the tag database is done generating, a message at the bottom of your Emacs prints a message GTAGS generated in ~/linux. Now you can start going anywhere in Linux source tree in an instant instead of spending hours to grep! Let's find a file in Linux. Every C program, whether large or small must have a <a class="el" href="_perfmon_c_r_t_2main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> function, and a file containing the function. Let's find out where the <a class="el" href="_perfmon_c_r_t_2main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> of Linux kernel is. M-x, type ggtags-find-file. C-c M-f also executes ggtags-find-file. A prompt ask for a file to find. You can also invoke ggtags-find-file with C-c M-f. Enter main.c to the prompt and press Enter. You will see a list of main.c files below in various directory: </p><center> <div class="image">
<img src="candidates.jpg" alt="candidates.jpg"/>
</div>
 </center><p>You can visit each file by pressing M-n (n means next) to go down or M-p to up (p means previous).</p>
<p>Press M-s s. A prompt appears waiting for something to search; type init/main.c. As you type, the candidate buffer got highlighted gradually.</p>
<p>Finally you get into the correct file. This is where Linux starts after the bootloader stage. Now, you see a lot of names in this file: variable names, function names… Now, you want to find where all of these names are defined and where they are used. Let's scroll down a bit, either with Page Down key or scrolling with the mouse or search for it. If you want to search, press C-s and type kernel_init and press C-s repeatedly. C-s is available everywhere in Emacs. M-s s is just available in ggtags. You see a function declaration like this:</p>
<p>static int kernel_init(void *); This is the whole process of finding the file: </p><center> <div class="image">
<img src="ggtags-find-file.gif" alt="ggtags-find-file.gif"/>
</div>
 </center><p>You can find definitions or references of a tag easily. Now, let's go back to the declaration static int kernel_init(void *); again. Move your cursor on kernel_init.</p>
<p>Press M-. jumps to its definition. M-. again jumps to its references, where the function is called. M-. again jumps to the definition again. Basically, if the current view is definition, pressing M-. switches to references and vice verse. Usually, you will also see a list of candidates similar to the one you saw using ggtags-find-file above. Use M-n or M-p to select next/previous match.</p>
<p>If you want to go back to where you were, press M-* (or M-Shift-8) brings you back to the previous place where you jumped.</p>
<p>If you want to jump to a C header file, for example:</p>
<p>#include &lt;linux/kernel.h&gt; Move your cursor onto that line and press M-..</p>
<p>Again, you can search for candidates using M-s s.</p>
<p>After navigating for a while, you may have jumped to many places. To view the history of where you were, press C-c M-h: </p><center> <div class="image">
<img src="ggtags-view-tag-history.gif" alt="ggtags-view-tag-history.gif"/>
</div>
 </center><p>If you want to have a list of all the tags you visited, press C-c M-/. The different between this command and the above command is that, C-c M-h stores the places in files you visited, while C-c M-/ stores the tag operations you performed. After press C-c M-/, if you select an entry in the result list, it displays the result list of the tag in the selected entry, along with your match candidate you selected in the past: </p><center> <div class="image">
<img src="ggtags-rerun.gif" alt="ggtags-rerun.gif"/>
</div>
 </center><p>If you create, edit or delete a source file in your project, upon saving ggtags automatically updates the database of your project. How convenient!</p>
<p>That's it for basic navigation. Yes, it's just the basic. This is just the tip of the iceberg. In Emacs, you have a toolchain called CEDET, short for Collection of Emacs Development Environment Tools, which offers features such as highlighting, project, smart jump, context-sensitive completion, symbol references, code generation… And Emacs includes CEDET by default from Emacs 23.2. CEDET is also a language framework for language writers to create such tools within Emacs for their languages, but currently the best supported language in CEDET is C/C++.</p>
<p>ggtags solves your navigation need, but does not offer the above features. However, with ggtags alone, it's far enough for your C/C++ projects, thanks to GNU Global for working nicely on large source tree like the Linux kernel.. After all, many people write C/C++ source code on a bare minimum editor and waste a lot of time doing things manually instead of focusing on their problems.</p>
<p>After this demo, are you convinced now? If you want to harness the power of Emacs even further, you need to learn Emacs properly. Finally, close everything you don't need with C-x k</p>
<p>Extending Emacs Primer To let Emacs automatically load your configuration, save it to either of these three files:</p>
<p>~/.emacs ~/.emacs.d/init.el ~/.emacs.d/init</p>
<p>Now you know how to open and save files, it's time to save your Emacs configuration you have been using in the <em>scratch</em> buffer. After you finish the Linux kernel browsing project, you have these configurations:</p>
<p>(require 'package) (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)</p>
<p>(add-hook 'c-mode-common-hook (lambda () (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode) (ggtags-mode 1))))</p>
<p>(add-hook 'dired-mode-hook 'ggtags-mode) If you like Ido, put the following configuration inside your init.el:</p>
<p>(setq ido-enable-flex-matching t) (setq ido-everywhere t) (ido-mode 1) You should use ~/.emacs.d/init.el because you can upload your ~/.emacs.d along with init.el on GitHub or Bitbucket, and it's more organized since Emacs saves many things under ~/.emacs.d/.</p>
<p>The steps:</p>
<p>Create a new file ~/.emacs.d/init.el with C-x C-f. After this, the buffer is created for this new file. M-w (copy) the above code snippet from <em>scratch</em> buffer and C-y (paste) into the init.el buffer. C-x C-s to save the buffer into file. Restart Emacs and test if it is effective. Try list-package to see if melpa is available. Try M-. in any source file in your linux kernel directory to see if it works properly. Conclusion That's it. Now you can start using Emacs for many things, from editing source code to managing files and reading documentation. I hope you find my manual useful for helping you get the hang of Emacs in as little time as possible, and I am really help if you do.</p>
<p>Remember, this is just the tip of the iceberg. There are more things Emacs is capable of. If you like, follow my other Emacs manuals on specific topics.</p>
<p>Finally, thanks to Worg for this awesome CSS.</p>
<p>Appendix Why Emacs? (Extended) Emacs allows you to do much more than just editing. Emacs is not a mere editor like others, either in terminal or in GUI. Emacs is a development platform. Emacs is a virtual machine that interprets its own bytecode.</p>
<p>You can write all sorts of programs in Emacs to add more features using its own language - Emacs Lisp - in an easy way. With this extensibility, Emacs can be many things: an editor, a file manager, an email client, a news reader, a shell…</p>
<p>You can think of Emacs as an enhanced interpreter and evaluate any valid Emacs Lisp code anywhere in Emacs, as long as the code is visible on your screen. To illustrate my point, here is an example:</p>
<p>(defun hello () (interactive) (message "Hello World")) You can paste that code snippet anywhere - yes, anywhere - in Emacs and tell Emacs to execute that code. If the code snippet has valid syntax, Emacs executes successfully and you will have command to print "Hello World" at the bottom of screen.</p>
<p>A great advantage of this approach is, if you want to change the behaviour of Emacs, you write some Emacs Lisp code, execute it and immediately see the results, right inside Emacs. Emacs is beyond an editor. Emacs is a programming platform that has an editor. Don't confuse Emacs with other real editors, which can only be used for editing.</p>
<p>In practice, Emacs also offers many editing interfaces: built-in Emacs, Ergoemacs and Evil - or Vim inside Emacs - key bindings. Emacs has internal tools and interfaces to external tools for many programming languages. Learning Emacs means you can use the same editor for different languages. Otherwise, you will have to learn a different editor when you learn a random language.</p>
<p>Other people's "Why Emacs?" "Why Emacs?" by Fabrice Popinea. He is the maintainer of Emacs 64 bit on Windows.</p>
<p>"Why Emacs?" by Bozhidar Batsov. He is the author of Emacs Prelude, an Emacs distribution with convenient packages for new people to get start with Emacs.</p>
<p>Why I use Emacs by Vincent Foley-Bourgon.</p>
<p>Why I Still Use Emacs, also by Vincent Foley-Bourgon.</p>
<p>Emacs is sexy.</p>
<p>More on Emacs history Ever heard of a computing system called Lisp Machine? I bet many of you don't. Me, too, until I started using Emacs and gradually learned enough to know such a thing ever existed. This old article is an interesting read: The Ghost in the Lisp Machine</p>
<p>A friend of mine used to say that Emacs fills our yearning for a Lisp Machine. I tend to agree with him: Emacs is not just an editor, but a full integrated environment where you can perform virtually any imaginable task; and, most importantly, the inner workings of the system are open to you to explore and extend. Using, for extra fun, Lisp. No, i don’t think that Elisp is the nicest Lisp incarnation around, but is far better than, say, C, and i still prefer it to other scripting languages. Moreover, the awesome range of libraries at your disposal makes up for many of the deficiencies in the language.</p>
<p>Living in Emacs is addictive. Imagine an operating system where you can switch from writing code to browsing the web or chatting without leaving a consistent environment, with the same set of commands and shortcuts. Imagine a set of integrated applications where data is seamlessly shared, where any single functionality can be tweaked, extended and adapted to your particular needs. Where everything is easily scriptable. Imagine, in addition, that the environment provides powerful and complete interactive self-documentation facilities with which the user can find out what is available. I have yet to find an operating system providing such an integrated environment. Not even Mac OS X, where AppleScript support is often lacking and system services are underused.</p>
<p>Of course, the key ingredient here is Emacs’ extensibility. Far from being an afterthought or simply one of its features, extensibility is the central aspect of Emacs’ architecture. Actually, the whole point of this post is to recommend you reading Richard Stallman’s 1981 essay EMACS: The Extensible, Customizable Display Editor, which explains much better than I could the strong points of Emacs design, i.e., those traits that make Emacs more, much more, than just an editor. From the horse’s mouth:</p>
<p>Extensibility means that the user can add new editing commands or change old ones to fit his editing needs, while he is editing. EMACS is written in a modular fashion, composed of many separate and independent functions. The user extends EMACS by adding or replacing functions, writing their definitions in the same language that was used to write the original EMACS system. We will explain below why this is the only method of extension which is practical in use: others are theoretically equally good but discourage use, or discourage nontrivial use.</p>
<p>[…]</p>
<p>User customization helps in another, subtler way, by making the whole user community into a breeding and testing ground for new ideas. Users think of small changes, try them, and give them to other usersCif an idea becomes popular, it can be incorporated into the core system. When we poll users on suggested changes, they can respond on the basis of actual experience rather than thought experiments.</p>
<p>The article goes on explaining the organization of the Emacs system, how it depends on its interpreter, Elisp’s main features and how built-in self-documentation is provided. Also interesting is the list of related systems at the end of the essay: Lisp machines, LOGO, MacLisp and Smalltalk. We’re definitely in good company!</p>
<p>Emacs is a miniature of a Lisp Machine. You can take a tour at the Lisp Machine online museum. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<hr>
<MARQUEE behavior="alternate">乡下小老鼠倾力打造 &reg</MARQUEE>
</html>
